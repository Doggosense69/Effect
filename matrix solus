local entity_get_local_player, client_screen_size, ui_reference, math_min, math_max, globals_tickinterval, globals_frametime, ui_set_visible, renderer_line, renderer_world_to_screen, ui_mouse_position, ui_menu_position, ui_menu_size, remove, client_trace_line, math_floor, renderer_gradient, renderer_measure_text, renderer_rectangle, renderer_text, renderer_triangle, renderer_circle, math_rad = entity.get_local_player, client.screen_size, ui.reference, math.min, math.max, globals.tickinterval, globals.frametime, ui.set_visible, renderer.line, renderer.world_to_screen, ui.mouse_position, ui.menu_position, ui.menu_size, table.remove, client.trace_line, math.floor, renderer.gradient, renderer.measure_text, renderer.rectangle, renderer.text, renderer.triangle, renderer.circle, math.rad
local entity_get_prop, math_sin, math_cos, globals_tickcount, globals_realtime, entity_is_alive, client_latency, ui_is_menu_open, client_key_state, client_set_clan_tag, entity_get_player_name, globals_framecount, client_set_event_callback, client_unset_event_callback = entity.get_prop, math.sin, math.cos, globals.tickcount, globals.realtime, entity.is_alive, client.latency, ui.is_menu_open, client.key_state, client.set_clan_tag, entity.get_player_name, globals.framecount, client.set_event_callback, client.unset_event_callback

local username = "Doggo"
local uid = "69"
local build = "MATRIX" --beta or live

local lp = entity_get_local_player()
local get = ui.get
local set = ui.set

local screen = {client_screen_size()}
local center = {screen[1] / 2, screen[2] / 2}
local color1 = {255, 255, 255, 255}
local color2 = {255, 255, 255, 255}

local G = {

    matrix_log_data = {
        enabled = false,
        modes = {},
        font_style = "Normal",
        data = {}
    },

    matrix_master_data = {},

    matrix_visual_data = {
        color = color1,
        color2 = color2,
        beta = build
    }

    
    
}


local callbacks = {}

local function insert(table, data)
    table[#table + 1] = data
end

local function create_callback(event, fn)
    insert(callbacks, {e = event, f = fn})
end

local ref = {
    thirdperson = {ui_reference("VISUALS", "Effects", "Force third person (alive)")},
    doubletap = {ui_reference("RAGE", "Aimbot", "Double tap")},
    onshot = {ui_reference("AA", "Other", "On shot anti-aim")},
    fakeduck = ui_reference("RAGE", "Other", "Duck peek assist"),
    safe_point = ui_reference("RAGE", "Aimbot", "Force safe point"),
    edge_yaw = ui_reference("AA", "Anti-aimbot angles", "Edge yaw"),
    freestanding = {ui_reference("AA", "Anti-aimbot angles", "Freestanding")},
    menu_color = ui_reference("MISC", "Settings", "Menu color"),
    spectator = ui_reference("VISUALS", "Other ESP", "Spectators"),
    force_body_aim = ui_reference("RAGE", "Aimbot", "Force body aim"),
    quick_peek = {ui_reference("RAGE", "Other", "Quick peek assist")},
    ping_spike = {ui_reference("MISC", "Miscellaneous", "Ping spike")}
}

local ui_fn = {
    includes = function(table, key)
        for i = 1, #table do
            if table[i] == key then
                return true, i
            end
        end

        return false
    end,

    set_visible = function(state, ...)
        local args = {...}

        for i = 1, #args do
            ui_set_visible(args[i], state)
        end
    end,

    mouse_within = function(x, y, w, h)
        local mouse = {ui_mouse_position()}
        local menu_pos = {ui_menu_position()}
        local menu_size = {ui_menu_size()}
        
        return mouse[1] > x and mouse[1] < x + w and mouse[2] > y and mouse[2] < y + h and not (mouse[1] > menu_pos[1] and mouse[1] < (menu_pos[1] + menu_size[1]) and mouse[2] > menu_pos[2] and mouse[2] < (menu_pos[2] + menu_size[2]))
    end
}

local math_fn = {
    TICKS_TO_TIME = function(ticks)
        return globals_tickinterval() * ticks
    end,

    clamp = function(min, max, value)
        if value >= max then
            return max
        elseif value <= min then
            return min
        else
            return value
        end
    end,

    normalize_yaw = function(yaw)
        yaw = (yaw % 360 + 360) % 360
        return yaw > 180 and yaw - 360 or yaw
    end,

    lerp = function(one, two, percent) 
        local return_results = {}
        for i=1, #one do
            return_results[i] = one[i] + (two[i] - one[i]) * percent
        end
        return return_results
    end,

    angle_forward = function(angle)
        local p, y = math_rad(angle[1]), math_rad(angle[2])
        local sp, cp, sy, cy = math_sin(p), math_cos(p), math_sin(y), math_cos(y)
        return {cp*cy, cp*sy, -sp}
    end,

    rotate_point = function(self, new_x, new_y, angle, distance)
        angle = self.normalize_yaw(angle)
    
        local cam = {client.camera_angles()}
        local x = math_sin(math_rad(angle - cam[2])) * distance 
        local y = math_cos(math_rad(angle - cam[2])) * distance 
        return new_x - x, new_y - y
    end,

    renderer_triangle = function(v2_A, v2_B, v2_C, r, g, b, a)
        v2_A = {x = v2_A[1], y = v2_A[2]}
        v2_B = {x = v2_B[1], y = v2_B[2]}
        v2_C = {x = v2_C[1], y = v2_C[2]}    
    
        local function i(j,k,l)
            local m=(k.y-j.y)*(l.x-k.x)-(k.x-j.x)*(l.y-k.y)
            if m<0 then return true end
            return false
        end
        if i(v2_A,v2_B,v2_C) then renderer_triangle(v2_A.x,v2_A.y,v2_B.x,v2_B.y,v2_C.x,v2_C.y,r,g,b,a)
        elseif i(v2_A,v2_C,v2_B) then renderer_triangle(v2_A.x,v2_A.y,v2_C.x,v2_C.y,v2_B.x,v2_B.y,r,g,b,a)
        elseif i(v2_B,v2_C,v2_A) then renderer_triangle(v2_B.x,v2_B.y,v2_C.x,v2_C.y,v2_A.x,v2_A.y,r,g,b,a)
        elseif i(v2_B,v2_A,v2_C) then renderer_triangle(v2_B.x,v2_B.y,v2_A.x,v2_A.y,v2_C.x,v2_C.y,r,g,b,a)
        elseif i(v2_C,v2_A,v2_B) then renderer_triangle(v2_C.x,v2_C.y,v2_A.x,v2_A.y,v2_B.x,v2_B.y,r,g,b,a)
        else renderer_triangle(v2_C.x,v2_C.y,v2_B.x,v2_B.y,v2_A.x,v2_A.y,r,g,b,a)end
    end,

    --[[
    dot = function(vec1, vec2)
        return vec1[1] * vec2[1] + vec1[2] * vec2[2] + vec1[3] * vec2[3]
    end,

    normalize_vector = function(vec)
        local len = math.sqrt(vec[1] * vec[1] + vec[2] * vec[2] + vec[3] * vec[3])
        if len == 0 then
            return 0, 0, 0
        end
        local r = 1 / len
        return {vec[1]*r, vec[2]*r, vec[3]*r}
    end,

    fov = function(self, start_pos, end_pos, angle)
        if start_pos == nil or end_pos == nil or angle == nil then
            return 180
        end

        local vec = self.angle_forward(angle)
        local normalize_vec = self.normalize_vector({end_pos[1] - start_pos[1], end_pos[2] - start_pos[2], end_pos[3] - start_pos[3]})

        return math.deg(math.acos(self.dot(vec, normalize_vec)))
    end,

    calc_angle = function(start_pos, end_pos)
        if start_pos == nil or end_pos == nil then
            return {0, 0}
        end

        local delta_x, delta_y, delta_z = end_pos[1] - start_pos[1], end_pos[2] - start_pos[2], end_pos[3] - start_pos[3]

        if delta_x == 0 and delta_y == 0 then
            return {(delta_z > 0 and 270 or 90), 0}
        else
            local hyp = math.sqrt(delta_x*delta_x + delta_y*delta_y)
    
            local pitch = math.deg(math.atan2(-delta_z, hyp))
            local yaw = math.deg(math.atan2(delta_y, delta_x))
    
            return {pitch, yaw}
        end
    end,
    ]]

    hsv_to_rgb = function(h, s, v) 
        local r, g, b

        h = h/360
        s = s/100
        v = v/100
        
        local i = math_floor(h * 6);
        local f = h * 6 - i;
        local p = v * (1 - s);
        local q = v * (1 - f * s);
        local t = v * (1 - (1 - f) * s);

        i = i % 6

        if i == 0 then r, g, b = v, t, p
        elseif i == 1 then r, g, b = q, v, p
        elseif i == 2 then r, g, b = p, v, t
        elseif i == 3 then r, g, b = p, q, v
        elseif i == 4 then r, g, b = t, p, v
        elseif i == 5 then r, g, b = v, p, q
        end

        return r * 255, g * 255, b * 255
    end,

    rainbow = function(self, speed, offset, s, v, a)
        --Default to if nothing was provided (retards)
        speed = speed or 10
        offset = offset or 0
        s = s or 100
        v = v or 100

        local h = ((globals_tickcount() * speed) % 360) + offset

        --Normalize
        while h > 360 do
            h = h - 360
        end

        while h < 0 do
            h = 360 - h
        end

        --Just incase...
        h = self.clamp(0, 360, h)

        local color = {self.hsv_to_rgb(h, s, v)}
        --Add alpha
        insert(color, a)

        return color
    end
}

local pos = {
    "LUA", 
    "B"
}

local menu = {
    enable = ui.new_checkbox(pos[1], pos[2], "Enable visuals"),
    explorer = ui.new_combobox(pos[1], pos[2], "\n", {"Logs", "Visuals", "Other"}),

    --logs
    logs = ui.new_checkbox(pos[1], pos[2], "Logs \n matrix"),
    logs_output = ui.new_multiselect(pos[1], pos[2], "Output \n matrix", {"Center", "Console", "Corner"}),
    logs_hit = ui.new_label(pos[1], pos[2], "Hit color"),
    logs_hit_color = ui.new_color_picker(pos[1], pos[2], "Hit color picker", 163, 255, 15, 255),
    logs_miss = ui.new_label(pos[1], pos[2], "Miss color"),
    logs_miss_color = ui.new_color_picker(pos[1], pos[2], "Miss color picker", 255, 50, 50, 255),
    
    main_visuals = ui.new_checkbox(pos[1], pos[2], "Visuals \n matrix"),
    visual_modes = ui.new_multiselect(pos[1], pos[2], "\n visual options", {"Watermark", "Crosshair", "Hotkey list", "Spectator list"}),
    crosshair_color = ui.new_color_picker(pos[1], pos[2], "Crosshair color picker", 220, 220, 220, 255),

    color_mode = ui.new_combobox(pos[1], pos[2], "Color mode", {"Gradient", "Static"}),

    --static options
    static_mode = ui.new_combobox(pos[1], pos[2], "Static mode", {"Static", "Fade", "Rainbow"}),
    static_label = ui.new_label(pos[1], pos[2], "color 1 \n static"),
    static_color = ui.new_color_picker(pos[1], pos[2], "Static color picker", 0, 238, 255, 255),
    static_label2 = ui.new_label(pos[1], pos[2], "color 2 \n static"),
    static_color2 = ui.new_color_picker(pos[1], pos[2], "Static 2 color picker", 149, 103, 255, 255),
    static_speed = ui.new_slider(pos[1], pos[2], "\n static speed", 1, 100, 50, false),

    --gradient options
    gradient_mode = ui.new_combobox(pos[1], pos[2], "Gradient mode", {"Rainbow", "Switch", "Custom"}),

    gradient_label = ui.new_label(pos[1], pos[2], "color 1 \n theme"),
    gradient_color = ui.new_color_picker(pos[1], pos[2], "Theme 1 color picker", 0, 238, 255, 255),
    gradient_label2 = ui.new_label(pos[1], pos[2], "color 2 \n theme"),
    gradient_color2 = ui.new_color_picker(pos[1], pos[2], "Theme 2 color picker", 149, 103, 255, 255),
    gradient_speed = ui.new_slider(pos[1], pos[2], "\n rainbow speed", 1, 100, 50, false),

    background_alpha = ui.new_slider(pos[1], pos[2], "Background alpha", 0, 255, 150, false),

    hotkey_x = ui.new_slider(pos[1], pos[2], "Hotkey x save", -100, 5000, 10),
    hotkey_y = ui.new_slider(pos[1], pos[2], "Hotkey y save", -100, 5000, center[2] - 100),

    spec_x = ui.new_slider(pos[1], pos[2], "Spec x save", -100, 5000, center[1] * 0.75),
    spec_y = ui.new_slider(pos[1], pos[2], "Spec y save", -100, 5000, 10),

    --resolver_x = ui.new_slider(pos[1], pos[2], "Resolver x save", -100, 5000, 10),
    --resolver_y = ui.new_slider(pos[1], pos[2], "Resolver y save", -100, 5000, center[2]/1.25),

    fireworks = ui.new_checkbox(pos[1], pos[2], "Fireworks"),
    firework_size = ui.new_combobox(pos[1], pos[2], "Size \n firework", {"Large", "Medium", "Small"}),
    firework_color = ui.new_combobox(pos[1], pos[2], "Color mode \n firework", {"Rainbow", "Custom"}),
    firework_label = ui.new_label(pos[1], pos[2], "color 1 \n explosion"),
    firework_color1 = ui.new_color_picker(pos[1], pos[2], "explosion 1 color picker", 0, 238, 255, 255),
    firework_label2 = ui.new_label(pos[1], pos[2], "color 2 \n explosion"),
    firework_color2 = ui.new_color_picker(pos[1], pos[2], "explosion 2 color picker", 149, 103, 255, 255),
    firework_speed = ui.new_slider(pos[1], pos[2], "Speed \n firework", 10, 75, 50, true, "%"),
    firework_limit = ui.new_slider(pos[1], pos[2], "Object limit \n firework", 1, 5, 2, true, "", 1, {[5] = "inf"}),

    explosion = ui.new_checkbox(pos[1], pos[2], "Explosion"),
    explosion_label = ui.new_label(pos[1], pos[2], "color 1 \n explosion"),
    explosion_color = ui.new_color_picker(pos[1], pos[2], "explosion 1 color picker", 0, 238, 255, 255),
    explosion_label2 = ui.new_label(pos[1], pos[2], "color 2 \n explosion"),
    explosion_color2 = ui.new_color_picker(pos[1], pos[2], "explosion 2 color picker", 149, 103, 255, 255),
    explosion_speed = ui.new_slider(pos[1], pos[2], "Speed \n explosion", 10, 200, 50, true, "%"),
    explosion_limit = ui.new_slider(pos[1], pos[2], "Object limit \n explo", 1, 5, 2, true, "", 1, {[5] = "inf"}),

    fps_saver = ui.new_checkbox(pos[1], pos[2], "VFX optimization"),
    clantag = ui.new_checkbox(pos[1], pos[2], "Clantag changer"),
    gui_reset = ui.new_checkbox(pos[1], pos[2], "Reset GUI POS"),

    fade_state = true,
    fade_amount = 0,

    run = function(self)
        lp = entity_get_local_player()

        local explorer_g = get(self.explorer)
        local state = get(self.enable)

        ui_fn.set_visible(state, self.explorer)
        ui_fn.set_visible(false, self.hotkey_x, self.hotkey_y, self.spec_x, self.spec_y --[[self.resolver_x, self.resolver_y]])

        ui_fn.set_visible(state and explorer_g == "Logs", self.logs)
        ui_fn.set_visible(state and get(self.logs) and explorer_g == "Logs", self.logs_output, self.logs_hit, self.logs_hit_color, self.logs_miss, self.logs_miss_color) --logs

        ui_fn.set_visible(state and explorer_g == "Visuals", self.main_visuals)
        ui_fn.set_visible(state and explorer_g == "Visuals" and get(self.main_visuals), self.color_mode)

        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and ui_fn.includes(get(self.visual_modes), "Watermark"), self.watermark_options)
        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and ui_fn.includes(get(self.visual_modes), "Crosshair"), self.crosshair_color)
        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and ui_fn.includes(get(self.visual_modes), "Crosshair"), self.crosshair_color)

        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and get(self.color_mode) == "Static", self.static_mode)
        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and get(self.color_mode) == "Static" and (get(self.static_mode) == "Static" or get(self.static_mode) == "Fade"), self.static_label, self.static_color)
        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and get(self.color_mode) == "Static" and get(self.static_mode) == "Fade", self.static_label2, self.static_color2)
        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and get(self.color_mode) == "Static" and (get(self.static_mode) == "Fade" or get(self.static_mode) == "Rainbow"), self.static_speed)

        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and get(self.color_mode) == "Gradient", self.gradient_mode)
        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and get(self.color_mode) == "Gradient" and (get(self.gradient_mode) == "Rainbow" or get(self.gradient_mode) == "Switch"), self.gradient_speed)
        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals" and get(self.color_mode) == "Gradient" and (get(self.gradient_mode) == "Custom" or get(self.gradient_mode) == "Switch"), self.gradient_label, self.gradient_color, self.gradient_color2, self.gradient_label2)

        ui_fn.set_visible(state and get(self.main_visuals) and explorer_g == "Visuals", self.visual_modes, self.background_alpha)

        ui_fn.set_visible(state and explorer_g == "Other", self.fireworks, self.clantag, self.explosion, self.fps_saver, self.gui_reset)
        ui_fn.set_visible(state and explorer_g == "Other" and get(self.fireworks), self.firework_color, self.firework_size, self.firework_speed, self.firework_limit)
        ui_fn.set_visible(state and explorer_g == "Other" and get(self.fireworks) and get(self.firework_color) == "Custom", self.firework_label, self.firework_color1, self.firework_label2, self.firework_color2)
        ui_fn.set_visible(state and explorer_g == "Other" and get(self.explosion), self.explosion_label, self.explosion_color, self.explosion_label2, self.explosion_color2, self.explosion_speed, self.explosion_limit)

        --Rainbow
        if get(self.main_visuals) then
            local rainbow_speed_g = (get(self.color_mode) == "Static" and get(self.static_speed) or get(self.gradient_speed)) / 20
            local rainbow_speed1 = math_fn:rainbow(rainbow_speed_g, 0, 50, 100, 255)
            local rainbow_speed2 = math_fn:rainbow(rainbow_speed_g, 100, 70, 100, 255)
 
            if get(self.color_mode) == "Static" then
                local static_mode_g = get(self.static_mode)

                local static_color_g = {get(self.static_color)}
                local static_color2_g = {get(self.static_color2)}

                if static_mode_g == "Static" then
                    color1 = static_color_g
                    color2 = static_color_g
                elseif static_mode_g == "Fade" then
                    local static_speed_g = (105 - get(self.static_speed)) / 75
                    local inc = (1 / static_speed_g) * globals_frametime()

                    if self.fade_state then
                        self.fade_amount = self.fade_amount + inc

                        if self.fade_amount >= 1 then
                            self.fade_state = false
                        end
                    else
                        self.fade_amount = self.fade_amount - inc

                        if self.fade_amount <= 0 then
                            self.fade_state = true
                        end
                    end
                    self.fade_amount = math_fn.clamp(0, 1, self.fade_amount)

                    local color_lerp = math_fn.lerp(static_color_g, static_color2_g, self.fade_amount)
                    color1 = color_lerp
                    color2 = color_lerp
                else
                    color1 = rainbow_speed1
                    color2 = rainbow_speed1
                end
            else --Gradient
                local gradient_mode_g = get(self.gradient_mode)
                local gradient_color_g = {get(self.gradient_color)}
                local gradient_color2_g = {get(self.gradient_color2)}

                if gradient_mode_g == "Custom" then
                    color1 = gradient_color_g
                    color2 = gradient_color2_g
                elseif gradient_mode_g == "Rainbow" then
                    color1 = rainbow_speed1
                    color2 = rainbow_speed2
                else
                    local rainbow_speed_g = (105 - get(self.gradient_speed)) / 75
                    local inc = (1 / rainbow_speed_g) * globals_frametime()

                    if self.fade_state then
                        self.fade_amount = self.fade_amount + inc

                        if self.fade_amount >= 1 then
                            self.fade_state = false
                        end
                    else
                        self.fade_amount = self.fade_amount - inc

                        if self.fade_amount <= 0 then
                            self.fade_state = true
                        end
                    end
                    self.fade_amount = math_fn.clamp(0, 1, self.fade_amount)

                    local color_lerp = math_fn.lerp(gradient_color_g, gradient_color2_g, self.fade_amount)
                    local color_lerp2 = math_fn.lerp(gradient_color2_g, gradient_color_g, self.fade_amount)

                    color1 = color_lerp
                    color2 = color_lerp2
                end
            end

            color1[4] = 255
            color2[4] = 255
        end
    end
}
create_callback("paint_ui", function() menu:run() end)

local right_click = {
    data = {
        log = {pos = {nil, nil}, size = {nil, nil}},
        crosshair_style = {pos = {nil, nil}, size = {nil, nil}},
        main_visuals = {pos = {nil, nil}, size = {nil, nil}},
        spectator = {pos = {nil, nil}, size = {nil, nil}},
        hotkey = {pos = {nil, nil}, size = {nil, nil}}
        --resolver = {pos = {nil, nil}, size = {nil, nil}},
    },
}

local gui = {
    data = {},
    temp_header_data = {},
    temp_push_data = {},

    update_size = function(self, index, pos, size)
        self.data[index].pos = pos
        self.data[index].size = size
    end,

    new = function(self, label_name, width, pos_func)
        self.temp_header_data = {
            name = label_name,
            width = width,

            cur_height = 1,

            click_pos = nil,

            active = false,
            alpha = 0,
    
            func = pos_func,
            last_pos = nil,

            elements = {}
        }
    end,

    label = function(self, name)
        self.temp_push_data[#self.temp_push_data + 1] = {
            "label",
            name
        }
    end,

    list = function(self, name, elements)
        local refs = {}

        local ui_get_refs = {}

        for i = 1, #elements do
            local check = ui.new_checkbox("LUA", "A", self.temp_header_data.name .. ": " .. name .. ": list: " .. elements[i])
            refs[#refs + 1] = check
            ui_get_refs[#ui_get_refs + 1] = {elements[i], check}
            ui_set_visible(refs[#refs], false)
        end

        insert(self.temp_header_data.elements, {"list", name, ui_get_refs})

        self.temp_push_data[#self.temp_push_data + 1] = {
            "list",
            elements,
            refs,
        }
    end,

    combo = function(self, name, elements)
        local ref = ui.new_combobox("LUA", "A", self.temp_header_data.name .. ": Combo: " .. name, elements)
        ui_set_visible(ref, false)
        insert(self.temp_header_data.elements, {"combo", name, ref})

        self.temp_push_data[#self.temp_push_data + 1] = {
            "combo",
            name,
            ref,
            elements,
        }
    end,

    push = function(self)
        self.data[#self.data + 1] = {
            self.temp_header_data,
            self.temp_push_data
        }

        self.temp_header_data = {}
        self.temp_push_data = {}

        return self.data[#self.data + 1]
    end,

    get_list = function(self, container_name, name)
        for i = 1, #self.data do
            local cur = self.data[i][1]

            if cur.name == container_name then
                for i2 = 1, #cur.elements do
                    local element = cur.elements[i2]

                    if element[1] == "list" and element[2] == name then
                        local active_data = {}

                        for i3 = 1, #element[3] do
                            local cur_element = element[3][i3]

                            if get(cur_element[2]) then
                                active_data[#active_data + 1] = cur_element[1]
                            end
                        end

                        return active_data
                    end
                end
            end
        end

        print("get_list -> Invalid element name")

        return {}
    end,

    get_combo = function(self, container_name, name)
        for i = 1, #self.data do
            local cur = self.data[i][1]

            if cur.name == container_name then
                for i2 = 1, #cur.elements do
                    local element = cur.elements[i2]

                    if element[1] == "combo" and element[2] == name then
                        return get(element[3])
                    end
                end
            end
        end

        print("get_combo -> Invalid element name")

        return {}
    end,

    init = function(self)
        --Crosshair header
        self:new("Crosshair style", 200, function()
            return {right_click.data.crosshair_style.pos[1], right_click.data.crosshair_style.pos[2], right_click.data.crosshair_style.size[1], right_click.data.crosshair_style.size[2]}, right_click.data.crosshair_style.pos[1] ~= nil
        end)

        self:label("Crosshair header font")
        self:combo("Header style", {
            "Normal",
            "Bold",
            "Large",
            "Small"
        })

        self:label("Crosshair font")
        self:combo("Text style", {
            "Normal",
            "Bold",
            "Small"
        })

        self:label("Anti-aim arrows")
        self:combo("Arrow style", {
            "Disabled",
            "Manual side",
            "Body side",
            "Freestand arrow"
        })

        self:label("Crosshair options")
        self:list("Options", {
            "Gradient bar",
            "Desync line",
            "Gradient background",
            "Double tap",
            "On shot anti-aim",
            "Fake flick",
            "Ping spike",
            "Force body aim",
            "Force safe point",
            "Quick peek",
            "Freestanding/Edge yaw"
        })

        self:label("Draw mode")
        self:combo("Only show when active", {
            "Only show when active",
            "Show when disabled"
        })

        self:push()

        --Logs
        self:new("Logs", 100, function()
            return {right_click.data.log.pos[1], right_click.data.log.pos[2], right_click.data.log.size[1], right_click.data.log.size[2]}, right_click.data.log.pos[1] ~= nil
        end)

        self:label("Log font")
        self:combo("Text style", {
            "Normal",
            "Bold",
            "Small",
            "Large"
        })

        self:push()

        --Watermark 
        self:new("Watermark", 140, function()
            return {right_click.data.main_visuals.pos[1], right_click.data.main_visuals.pos[2], right_click.data.main_visuals.size[1], right_click.data.main_visuals.size[2]}, right_click.data.main_visuals.pos[1] ~= nil
        end)

        self:label("Watermark font")
        self:combo("Text style", {
            "Normal",
            "Bold"
        })

        self:label("Watermark options")
        self:list("Watermark options", {
            "Username",
            "Tickrate",
            "Ping",
            "Avg. fps"
        })

        self:label("Watermark style")
        self:combo("Background style", {
            "Normal",
            "Normal rounded",
            "Legacy",
            "Legacy rounded",
            "Legacy v2",
            "Basic"
        })

        self:push()

        --Spec
        self:new("Spec", 100, function()
            return {right_click.data.spectator.pos[1], right_click.data.spectator.pos[2], right_click.data.spectator.size[1], right_click.data.spectator.size[2]}, right_click.data.spectator.pos[1] ~= nil
        end)

        self:label("Header font")
        self:combo("Header style", {
            "Normal",
            "Bold"
        })

        self:label("Spectator font")
        self:combo("Text style", {
            "Normal",
            "Bold"
        })

        
        self:label("Spectator style")
        self:combo("Background style", {
            "Normal",
            "Normal rounded",
            "Legacy",
            "Legacy rounded",
            "Legacy v2",
            "Basic"
        })

        self:push()

        --Hotkey list
        self:new("Hotkey", 150, function()
            return {right_click.data.hotkey.pos[1], right_click.data.hotkey.pos[2], right_click.data.hotkey.size[1], right_click.data.hotkey.size[2]}, right_click.data.hotkey.pos[1] ~= nil
        end)

        self:label("Header font")
        self:combo("Header style", {
            "Normal",
            "Bold"
        })

        self:label("Text font")
        self:combo("Text style", {
            "Normal",
            "Bold"
        })

        self:label("Indicator style")
        self:combo("Background style", {
            "Normal",
            "Normal rounded",
            "Legacy",
            "Legacy rounded",
            "Legacy v2",
            "Basic"
        })

        self:label("Slider options")
        self:list("Hotkey options", {
            "Double tap",
            "Fake lag",
            "Lag compensation",
            "Bomb timer"
        })

        self:push()

        --resolver
        --[[
        self:new("Resolver", 100, function()
            return {right_click.data.resolver.pos[1], right_click.data.resolver.pos[2], right_click.data.resolver.size[1], right_click.data.resolver.size[2]}, right_click.data.resolver.pos[1] ~= nil
        end)

        self:label("Resolver font")
        self:combo("Text style", {
            "Normal",
            "Bold"
        })

        self:label("Resolver style")
        self:combo("Background style", {
            "Normal",
            "Normal rounded",
            "Legacy",
            "Legacy rounded",
            "Legacy v2",
            "Basic"
        })

        self:push()
        ]]
    end,

    measure = function(header, bodies)
        local height = 0

        for i = 1, #bodies do
            local body = bodies[i]

            if body[1] == "label" then
                local text_size = {renderer_measure_text("", body[2])}
                height = height + text_size[2] + 2
            elseif body[1] == "list" then
                local text_offset = 4
                local max_width = header.width - 8
                
                height = height + 15

                for i2 = 1, #body[2] do
                    local text_size = {renderer_measure_text(get(body[3][i2]) and "b" or "", body[2][i2])}

                    if text_offset + text_size[1] > max_width then
                        text_offset = 4
                        height = height + 12
                    end
                    text_offset = text_offset + text_size[1] + 7
                end
            elseif body[1] == "combo" then
                local text_size = {renderer_measure_text("", get(body[3]))}
                height = height + text_size[2] + 5
            end
        end

        return height
    end,

    left_state = false,
    left_release = false,
    right_state = false,
    right_release = false,
    active_dropdowns = false,
    indicator_alpha = 0,

    run = function(self)
        local menu_inc = (255 / 0.1) * globals_frametime()
        local menu_dec = (255 / 0.2) * globals_frametime()
        local menu_open = ui_is_menu_open()

        local active_color = {get(ref.menu_color)}
        local hover_color = {255, 255, 255, 255}
        local disabled_color = {200, 200, 200, 255}

        --left key
        self.left_release = false
        local left_key = client_key_state(0x01)
        if left_key ~= self.left_state then
            if left_key == false then
                self.left_release = true
            end

            self.left_state = left_key
        end

        --right key
        self.right_release = false
        local right_key = client_key_state(0x02)
        if right_key ~= self.right_state then
            if right_key == false then
                self.right_release = true
            end

            self.right_state = right_key
        end

        local mouse = {ui_mouse_position()}
        local indicator_text = "Right click me!"
        local indicator_size = {renderer_measure_text("", indicator_text)}
        local indicator_position = {math_fn.clamp(0, screen[1] - indicator_size[1] - 4, mouse[1] + 15), math_fn.clamp(0, screen[2] - indicator_size[2] - 4, mouse[2] + 15)}
        renderer_rectangle(indicator_position[1] - 2, indicator_position[2] - 2, indicator_size[1] + 4, indicator_size[2] + 4, 25, 25, 25, self.indicator_alpha)
        renderer_text(indicator_position[1], indicator_position[2], 255, 255, 255, self.indicator_alpha, "", 0, indicator_text)

        local hover_zone = false

        self.active_dropdowns = false

        for i = 1, #self.data do
            local data = self.data[i]
            local header = data[1]

            local _, pos_active = header.func()

            if pos_active and header.active then
                if header.active then
                    self.active_dropdowns = true
                    break
                end
            end
        end

        --do
        for i = 1, #self.data do
            local data = self.data[i]

            local header = data[1]
            local body = data[2]

            local pos, pos_active = header.func()

            if pos_active then
                local est_height = self.measure(header, body)

                if (header.active == false and ui_fn.mouse_within(pos[1], pos[2], pos[3], pos[4])) and menu_open and not self.active_dropdowns then
                    if self.right_release and header.click_pos == nil then

                        header.click_pos = {
                            math_fn.clamp(0, screen[1] - header.width - 4, mouse[1]),
                            math_fn.clamp(0, screen[2] - est_height, mouse[2]),
                        }
                        self.indicator_alpha = 0
                        header.active = true
                    else
                        hover_zone = true
                    end
                elseif self.left_release or self.right_release or menu_open == false then
                    if header.last_pos ~= nil and menu_open then
                        if ui_fn.mouse_within(header.last_pos[1], header.last_pos[2], header.width, est_height) == false then
                            header.active = false
                        end
                    else
                        header.active = false
                    end
                end

                if header.active then
                    header.last_pos = header.click_pos
                    header.alpha = header.alpha + menu_inc
                else
                    header.click_pos = nil
                    header.alpha = header.alpha - menu_dec
                end
                header.alpha = math_fn.clamp(0, 255, header.alpha)

                if header.alpha > 0 then
                    if header.cur_height < est_height then
                        header.cur_height = header.cur_height + (est_height / 0.15) * globals_frametime()
                    end
                else
                    header.cur_height = 0
                end

                header.cur_height = math_fn.clamp(0, est_height, header.cur_height)

                if header.alpha > 0 then
                    renderer_rectangle(header.last_pos[1] - 4, header.last_pos[2] - 4, header.width + 8, header.cur_height + 8, 0, 0, 0, header.alpha)
                    renderer_rectangle(header.last_pos[1] - 3, header.last_pos[2] - 3, header.width + 6, header.cur_height + 6, 50, 50, 50, header.alpha)
                    renderer_rectangle(header.last_pos[1] - 1, header.last_pos[2] - 1, header.width + 2, header.cur_height + 2, 25, 25, 25, header.alpha)
                    
                    local height = 0

                    for i = 1, #body do
                        local cur_body = body[i]
    
                        if cur_body[1] == "label" then
                            local text_size = {renderer_measure_text("", cur_body[2])}
                            
                            if header.cur_height >= height + text_size[2] + 2 then
                                renderer_rectangle(header.last_pos[1], header.last_pos[2] + height, header.width, text_size[2] + 1, 10, 10, 10, header.alpha)
                                renderer_text(header.last_pos[1] + 4, header.last_pos[2] + height, active_color[1], active_color[2], active_color[3], header.alpha, "", 0, cur_body[2])
                            end
                            height = height + text_size[2] + 2
                        elseif cur_body[1] == "list" then
                            local text_offset = 4
                            local max_width = header.width - 8

                            for i2 = 1, #cur_body[2] do
                                local state = get(cur_body[3][i2])

                                local color = state and active_color or disabled_color
                                local flag = state and "b" or ""
                                local text_size = {renderer_measure_text(flag, cur_body[2][i2])}
            
                                if text_offset + text_size[1] > max_width then
                                    text_offset = 4
                                    height = height + 12
                                end

                                local hover = ui_fn.mouse_within(header.last_pos[1] + text_offset - 3, header.last_pos[2] + height, text_size[1] + 6, text_size[2])

                                if hover then
                                    if state == false then
                                        color = hover_color
                                    end

                                    if self.left_release then
                                        set(cur_body[3][i2], not state)
                                    end 
                                end
                                if header.cur_height >= height + text_size[2] then
                                    renderer_text(header.last_pos[1] + text_offset, header.last_pos[2] + height, color[1], color[2], color[3], math_fn.clamp(0, 225, header.alpha), flag, 0, cur_body[2][i2])
                                end

                                text_offset = text_offset + text_size[1] + 7
                            end
                            height = height + 15
                        elseif cur_body[1] == "combo" then
                            local item = get(cur_body[3])
                            local text_size = {renderer_measure_text("b", item)}

                            if ui_fn.mouse_within(header.last_pos[1], header.last_pos[2] + height + 1, header.width, text_size[2] + 7) and (self.left_release or self.right_release) then
                                local items = cur_body[4]

                                local item_pos = 0

                                for i = 1, #items do
                                    if items[i] == item then
                                        item_pos = i
                                        break
                                    end
                                end

                                if self.left_release then
                                    if item_pos + 1 > #items then
                                        item_pos = 1
                                    else 
                                        item_pos = item_pos + 1
                                    end
                                elseif self.right_release then
                                    if item_pos - 1 < 1 then
                                        item_pos = #items
                                    else 
                                        item_pos = item_pos - 1
                                    end
                                end
                                set(cur_body[3], items[item_pos])
                            end
                            
                            if header.cur_height >= height + text_size[2] then
                                renderer_text(header.last_pos[1] + 4, header.last_pos[2] + height + 1, active_color[1], active_color[2], active_color[3], math_fn.clamp(0, 225, header.alpha), "b", 0, item)
                            end

                            height = height + text_size[2] + 5
                        end
                    end
                end
            end
        end

        if hover_zone then
            self.indicator_alpha = math_fn.clamp(0, 255, self.indicator_alpha + ((255 / 0.1) * globals_frametime()))
        else
            self.indicator_alpha = math_fn.clamp(0, 255, self.indicator_alpha - ((255 / 0.05) * globals_frametime()))
        end
    end,

    setup_command = function(self, cmd)
        if ui_is_menu_open() == false then
            return
        end

        for i = 1, #self.data do
            if self.data[i][1].active then
                cmd.in_attack = 0
                cmd.in_attack2 = 0
                break
            else
                local pos, pos_active = self.data[i][1].func()

                if pos_active and ui_fn.mouse_within(pos[1], pos[2], pos[3], pos[4]) then
                    cmd.in_attack = 0
                    cmd.in_attack2 = 0
                    break
                end
            end
        end
    end,
}
gui:init()

local logs = {
    multicolor_console = function(texts)
        for i=1, #texts do
            local text = texts[i]
            client.color_log(text[1][1], text[1][2], text[1][3], i ~= #texts and (text[2] .. '\0') or text[2])
        end
    end,

    logs_data = {},

    create_center_log = function(self, time, data)
        self.logs_data[#self.logs_data + 1] = {
            text = data,
            cur_offset = 0,
            alpha = 0,
            time = globals_realtime() + time
        }
    end,

    corner_data = {},

    create_corner_log = function(self, time, data)
        table.insert(self.corner_data, {
            text = data,
            alpha = 0,
            time = globals_realtime() + time
        })
    end,

    center_run = function(self)
        local alpha_inc = (255/0.25) * globals.frametime()
        local offset = 0
        local flags = ""
        local uppercase = false
        local log_font_g = gui:get_combo("Logs", "Text style")
        

        if log_font_g == "Normal" then
            flags = ""
        elseif log_font_g == "Bold" then
            flags = "b"
        else
            flags = "-"
            uppercase = true
        end

        local min_x = screen[1]
        local max_x = 0

        for i=#self.logs_data, 1, -1 do
            if self.logs_data[i] ~= nil then
                local data = self.logs_data[i]
                local table_text = data.text

                data.alpha = math_fn.clamp(0, 255, data.time < globals.realtime() and data.alpha - alpha_inc or data.alpha + alpha_inc)

                if data.cur_offset ~= offset then
                    data.cur_offset = math_fn.clamp(0, offset, data.cur_offset < offset and data.cur_offset + (200 * globals.frametime()) or offset)
                end
                local raw_text = ''

                for i2=1, #data.text do
                    raw_text = raw_text .. data.text[i2][2]
                end

                if uppercase then
                    raw_text = string.upper(raw_text)
                end
                
                local total_size = {renderer.measure_text(flags, raw_text)}

                local percent = 1-(data.alpha/255)
                local x_offset = data.time > globals.realtime() and -percent*40 or percent*40

                local text_height = 0
                local text_offset = 0

                for i2=1, #data.text do
                    local cur_table_text = data.text[i2]

                    local text = cur_table_text[2]
                    if uppercase then
                        text = string.upper(cur_table_text[2])
                    end

                    local text_size = {renderer.measure_text(flags, text)}

                    if text_height < text_size[2] then
                        text_height = text_size[2]
                    end

                    renderer.text((center[1] - total_size[1]/2) + text_offset + x_offset, screen[2] - 300 + data.cur_offset, cur_table_text[1][1], cur_table_text[1][2], cur_table_text[1][3], data.alpha, flags, 0, text)
                    text_offset = text_offset + text_size[1] + (uppercase and 1 or 0)
                end

                if (center[1] - total_size[1]/2) < min_x then
                    min_x = center[1] - total_size[1]/2
                end

                if max_x < text_offset then
                    max_x = text_offset
                end

                offset = offset + text_height + 2
            end
        end
        --gui:update_size(1, {center[1] - 300, screen[2] - 300}, {600, 200})


        for i=1, #self.logs_data do
            local dif_from_newest = #self.logs_data - i 

            if dif_from_newest > 5 then
                self.logs_data[i].time = 0
            end
        end

        --Remove old logs
        for i=#self.logs_data, 1, -1 do
            local data = self.logs_data[i]
            if data.alpha == 0 and data.time < globals.realtime() then
                table.remove(self.logs_data, i)
            end
        end 
    end,

    corner_run = function(self)
        local alpha_inc = (255/0.3) * globals.frametime()
        local dec = (20 / 0.3) * globals.frametime()
        local offset = -10

        for i = #self.corner_data, 1, -1 do
            local delta = #self.corner_data - i

            if delta > 7 then
                table.remove(self.corner_data, i)
            end
        end

        for i = 1, #self.corner_data do
            local log = self.corner_data[i]

            if log then
                if log.time < globals.realtime() then
                    log.alpha = math.max(0, log.alpha - alpha_inc)

                    if log.alpha == 0 then
                        table.remove(self.corner_data, i)
                    end
                else
                    log.alpha = math.min(255, log.alpha + alpha_inc)
                end

                local x_offset = 5

                for j = 1, #log.text do
                    local text = log.text[j]
                    local size = {renderer.measure_text("", text[2])}
                    renderer.text(x_offset, offset + 10, text[1][1], text[1][2], text[1][3], log.alpha, "", 0, text[2])
                    x_offset = x_offset + size[1]
                end

                offset = offset + 13
            end
        end
    end,

    white = {255, 255, 255, 255},
    hitgroup_names = {"generic", "head", "chest", "stomach", "left arm", "right arm", "left leg", "right leg", "neck", "?", "gear"},

    fire_logs = {},

    aim_fire = function(self, e)
        self.fire_logs[#self.fire_logs + 1] = {
            id = e.id,
            pred_hc = e.hit_chance,
            pred_hb = e.hitgroup,
            pred_dmg = e.damage
        }
    end,


    aim_hit = function(self, e)
        for i = 1, #self.fire_logs do
            local log = self.fire_logs[i]

            if log.id == e.id then
                local name = entity.get_player_name(e.target)
                local hitbox = self.hitgroup_names[e.hitgroup + 1]
                local health = entity_get_prop(e.target, "m_iHealth") or 0
                local bt = globals_tickcount()-e.tick
                local output = get(menu.logs_output)
                local hit_color = {get(menu.logs_hit_color)}
                
                if ui_fn.includes(output, "Center") then
                    self:create_center_log(5, {
                        {self.white, "Hit "},
                        {hit_color, name},
                        {self.white, " in the "},
                        {hit_color, hitbox},
                        {self.white, " for "},
                        {hit_color, e.damage},
                        {self.white, " dmg ("},
                        {hit_color, health},
                        {self.white, " hp left)"}
                    })
                end

                local text = {
                    {self.white, "["},
                    {hit_color, "void"},
                    {self.white, "] "},
                    {self.white, "Hit "},
                    {hit_color, name},
                    {self.white, " in the "},
                    {hit_color, hitbox},
                    {self.white, " for "},
                    {hit_color, e.damage},
                    {self.white, " dmg ("},
                    {hit_color, health},
                    {self.white, " hp left, hc: "},
                    {hit_color, math_floor(e.hit_chance)},
                    {self.white, ", skeet hc: "},
                    {hit_color, math_floor(log.pred_hc)},
                    {self.white, ", skeet hb: "},
                    {hit_color, self.hitgroup_names[log.pred_hb + 1]},
                    {self.white, ", skeet dmg: "},
                    {hit_color, log.pred_dmg},
                    {self.white, " bt: "},
                    {hit_color, bt},
                    {self.white, ")"}
                }
                
                if ui_fn.includes(output, "Corner") then
                    self:create_corner_log(5, text)
                end
                
                if ui_fn.includes(output, "Console") then
                    self.multicolor_console(text)
                end 

                table.remove(self.fire_logs, i)   
                break
            end
        end
    end,

    aim_miss = function(self, e)
        for i = 1, #self.fire_logs do
            local log = self.fire_logs[i]

            if log.id == e.id then
                local name = entity.get_player_name(e.target)
                local hitbox = self.hitgroup_names[e.hitgroup + 1]
                local reason = e.reason == "?" and "resolver" or e.reason
                local bt = globals_tickcount()-e.tick
                local output = get(menu.logs_output)
                local miss_color = {get(menu.logs_miss_color)}
                
                if ui_fn.includes(output, "Center") then
                    self:create_center_log(5, {
                        {self.white, "Missed "},
                        {miss_color, name},
                        {self.white, "'s "},
                        {miss_color, hitbox},
                        {self.white, " due to "},
                        {miss_color, reason},
                        {self.white, " ("},
                        {miss_color, math_floor(e.hit_chance)},
                        {self.white, "% hc)"}
                    })
                end

                local text = {
                    {self.white, "["},
                    {miss_color, "void"},
                    {self.white, "] "},
                    {self.white, "Missed "},
                    {miss_color, name},
                    {self.white, "'s "},
                    {miss_color, hitbox},
                    {self.white, " due to "},
                    {miss_color, reason},
                    {self.white, " (hc: "},
                    {miss_color, math_floor(e.hit_chance)},
                    {self.white, ", skeet hc: "},
                    {miss_color, math_floor(log.pred_hc)},
                    {self.white, ", skeet hb: "},
                    {miss_color, self.hitgroup_names[log.pred_hb + 1]},
                    {self.white, ", skeet dmg:"},
                    {miss_color, log.pred_dmg},
                    {self.white, " bt: "},
                    {miss_color, bt},
                    {self.white, ")"}
                }

                if ui_fn.includes(output, "Corner") then
                    self:create_corner_log(5, text)
                end

                if ui_fn.includes(output, "Console") then
                    self.multicolor_console(text)
                end 

                table.remove(self.fire_logs, i)   
                break
            end
        end
    end,

    run = function(self)
        right_click.data.log.pos = {center[1] - 300, screen[2] - 300}
        right_click.data.log.size = {600, 200}

        if get(menu.enable) == false or get(menu.logs) == false then
            right_click.data.log.pos = {nil, nil}
            right_click.data.log.size = {nil, nil}
        end
    end
}

local callbacksz = {
    weapon_fire = function(e)
        local player = client.userid_to_entindex(e.userid)

        if player ~= nil and lp ~= nil and player == lp then
            antiaim.sent_since_shot = false
        end
    end,
}
create_callback("paint", function() logs:run() end)
create_callback("paint_ui", function() logs:center_run() end)
create_callback("paint_ui", function() logs:corner_run() end)
create_callback("weapon_fire", function(e) callbacksz:weapon_fire(e) end)
create_callback("aim_fire", function(e) logs:aim_fire(e) end)
create_callback("aim_hit", function(e) logs:aim_hit(e) end)
create_callback("aim_miss", function(e) logs:aim_miss(e) end)

local void_visuals = nil

local shared_data = {
    name = "void_data",
    data = nil,

    read_data = function(self)
        self.data = database.read("void")

        void_visuals = {
            color = color1,
            color2 = color2,
            beta = build == "DEV",
            menu_color = menu_color
        }
        database.write("void_visuals", void_visuals)
    end
}
create_callback("paint", function() shared_data:read_data() end)

local styles = {
    rounded_rectangle = function(position, size, color1, color2, color3, color4, background, max_alpha, radius, outline_padding, outline_thickness)
        size[2] = size[2] + 1
        max_alpha = max_alpha or 255
        outline_padding = outline_padding or 1
        outline_thickness = outline_thickness or 1
        radius = math_max(radius, 2)
    
        --middle background
        renderer_rectangle(position[1] + radius, position[2] + radius, size[1] - (radius * 2), size[2] - (radius * 2), background[1], background[2], background[3], background[4])
    
        --left, right, top, bottom
        renderer_rectangle(position[1] + radius, position[2], size[1] - (radius * 2), radius, background[1], background[2], background[3], background[4])
        renderer_rectangle(position[1], position[2] + radius, radius, size[2] - (radius * 2), background[1], background[2], background[3], background[4])
        renderer_rectangle(position[1] + radius, position[2] + size[2] - radius, size[1] - (radius * 2), radius, background[1], background[2], background[3], background[4])
        renderer_rectangle(position[1] + size[1] - radius, position[2] + radius, radius, size[2] - (radius * 2), background[1], background[2], background[3], background[4])
    
        --edges, left, right, top, bottom
        renderer_circle(position[1] + radius, position[2] + radius, background[1], background[2], background[3], background[4], radius, 180, 0.25)
        renderer_circle(position[1] + size[1] - radius, position[2] + radius, background[1], background[2], background[3], background[4], radius, 90, 0.25)
        renderer_circle(position[1] + radius, position[2] + size[2] - radius, background[1], background[2], background[3], background[4], radius, 270, 0.25)
        renderer_circle(position[1] + size[1] - radius, position[2] + size[2] - radius, background[1], background[2], background[3], background[4], radius, 0, 0.25)
    
        --color outline
        renderer_gradient(position[1] + radius, position[2] + outline_padding, size[1] - (radius * 2), outline_thickness, color1[1], color1[2], color1[3], color1[4], color2[1], color2[2], color2[3], color2[4], true)
        renderer_gradient(position[1] + size[1] - outline_padding - outline_thickness, position[2] + radius, outline_thickness, size[2] - (radius * 2), color2[1], color2[2], color2[3], color2[4], color3[1], color3[2], color3[3], color3[4], false)
        renderer_gradient(position[1] + radius, position[2] + size[2] - outline_padding - outline_thickness, size[1] - (radius * 2), outline_thickness, color4[1], color4[2], color4[3], color4[4], color3[1], color3[2], color3[3], color3[4], true)
        renderer_gradient(position[1] + outline_padding, position[2] + radius, outline_thickness, size[2] - (radius * 2), color1[1], color1[2], color1[3], color1[4], color4[1], color4[2], color4[3], color4[4], false)
    
        --outline edges
        renderer.circle_outline(position[1] + radius + outline_padding, position[2] + radius + outline_padding, color1[1], color1[2], color1[3], color1[4], radius, 180, 0.25, outline_thickness)
        renderer.circle_outline(position[1] + size[1] - radius - outline_padding, position[2] + radius + outline_padding, color2[1], color2[2], color2[3], color2[4], radius, 270, 0.25, outline_thickness)
        renderer.circle_outline(position[1] + radius + outline_padding, position[2] + size[2] - radius - outline_padding, color4[1], color4[2], color4[3], color4[4], radius, 90, 0.25, outline_thickness)
        renderer.circle_outline(position[1] + size[1] - radius - outline_padding, position[2] + size[2] - radius - outline_padding, color3[1], color3[2], color3[3], color3[4], radius, 0, 0.25, outline_thickness)
    end,

    background = function(self, style_name, pos, size, color1, color2, max_alpha)
        local alpha_ovr = max_alpha or 255

        local alpha = math_fn.clamp(0, get(menu.background_alpha), alpha_ovr)
        if style_name == "Normal" then
            renderer_rectangle(pos[1], pos[2], size[1], size[2], 25, 25, 25, alpha)
            renderer_gradient(pos[1] + 1, pos[2] + 1, size[1] - 2, 2, color1[1], color1[2], color1[3], alpha_ovr, color2[1], color2[2], color2[3], alpha_ovr, true)
            renderer_gradient(pos[1] + 1, pos[2] + 3, 1, size[2] - 4, color1[1], color1[2], color1[3], alpha_ovr, color1[1], color1[2], color1[3], 0, false)
            renderer_gradient(pos[1] + size[1] - 2, pos[2] + 3, 1, size[2] - 4, color2[1], color2[2], color2[3], alpha_ovr, color2[1], color2[2], color2[3], 0, false)
        elseif style_name == "Basic" then
            renderer_rectangle(pos[1], pos[2], size[1], size[2], 25, 25, 25, alpha)
            renderer_gradient(pos[1] + 1, pos[2] + 1, size[1] - 2, 2, color1[1], color1[2], color1[3], alpha_ovr, color2[1], color2[2], color2[3], alpha_ovr, true)
        elseif style_name == "Normal rounded" then
            self.rounded_rectangle(pos, size, {color1[1], color1[2], color1[3], alpha_ovr}, {color2[1], color2[2], color2[3], alpha_ovr}, {color2[1], color2[2], color2[3], 0}, {color1[1], color1[2], color1[3], 0}, {25, 25, 25, alpha_ovr}, alpha_ovr, 3, 1, 1)
        elseif style_name == "Legacy rounded" then
            self.rounded_rectangle(pos, size, {color1[1], color1[2], color1[3], alpha_ovr}, {color2[1], color2[2], color2[3], alpha_ovr}, {color2[1], color2[2], color2[3], alpha_ovr}, {color1[1], color1[2], color1[3], alpha_ovr}, {25, 25, 25, alpha_ovr}, alpha_ovr, 3, 1, 1)
        elseif style_name == "Legacy" then
            renderer_rectangle(pos[1], pos[2], size[1], size[2] + 1, 25, 25, 25, alpha)
            renderer_gradient(pos[1] + 1, pos[2] + 1, size[1] - 2, 1, color1[1], color1[2], color1[3], alpha_ovr, color2[1], color2[2], color2[3], alpha_ovr, true)
            renderer_gradient(pos[1] + 1, pos[2] + 1, 1, size[2] - 2, color1[1], color1[2], color1[3], alpha_ovr, color1[1], color1[2], color1[3], alpha_ovr, false)
            renderer_gradient(pos[1] + size[1] - 2, pos[2] + 1, 1, size[2] - 2, color2[1], color2[2], color2[3], alpha_ovr, color2[1], color2[2], color2[3], alpha_ovr, false)
            renderer_gradient(pos[1] + 1, pos[2] + size[2] - 1, size[1] - 2, 1, color1[1], color1[2], color1[3], alpha_ovr, color2[1], color2[2], color2[3], alpha_ovr, true)
        elseif style_name == "Legacy v2" then
            alpha = math_fn.clamp(0, 100, alpha)
            alpha = math_fn.clamp(0, alpha_ovr, alpha)

            renderer_gradient(pos[1], pos[2], size[1], size[2] + 1, color1[1], color1[2], color1[3], alpha, color2[1], color2[2], color2[3], alpha, true)
            renderer_gradient(pos[1] + 1, pos[2] + 1, size[1] - 2, 1, color1[1], color1[2], color1[3], alpha_ovr, color2[1], color2[2], color2[3], alpha_ovr, true)
            renderer_gradient(pos[1] + 1, pos[2] + 1, 1, size[2] - 2, color1[1], color1[2], color1[3], alpha_ovr, color1[1], color1[2], color1[3], alpha_ovr, false)
            renderer_gradient(pos[1] + size[1] - 2, pos[2] + 1, 1, size[2] - 2, color2[1], color2[2], color2[3], alpha_ovr, color2[1], color2[2], color2[3], alpha_ovr, false)
            renderer_gradient(pos[1] + 1, pos[2] + size[2] - 1, size[1] - 2, 1, color1[1], color1[2], color1[3], alpha_ovr, color2[1], color2[2], color2[3], alpha_ovr, true)
        end
    end,
}

local crosshair = {
    draw_arrow = function(self, style, angle, dist, color, color2, size, max_alpha)
        local alpha = max_alpha or 255

        local x, y = math_fn:rotate_point(center[1], center[2], angle, dist)

        local top_point = {math_fn:rotate_point(x, y, math_fn.normalize_yaw(angle), size)}
        local left_point = {math_fn:rotate_point(x, y, math_fn.normalize_yaw(angle + 180 - 90), size/2)}
        local right_point = {math_fn:rotate_point(x, y, math_fn.normalize_yaw(angle + 180 + 90), size/2)}
        local middle_point = {math_fn:rotate_point(x, y, math_fn.normalize_yaw(angle + 180), -1)}

        math_fn.renderer_triangle(top_point, left_point, middle_point, color[1], color[2], color[3], color[4]/2)
        math_fn.renderer_triangle(top_point, right_point, middle_point, color2[1], color2[2], color2[3], color[4]/2)
        renderer.line(top_point[1], top_point[2], left_point[1], left_point[2], color[1], color[2], color[3], color[4])
        renderer.line(top_point[1], top_point[2], right_point[1], right_point[2], color[1], color[2], color[3], color[4])
        renderer.line(right_point[1], right_point[2], middle_point[1], middle_point[2], color[1], color[2], color[3], color[4])
        renderer.line(left_point[1], left_point[2], middle_point[1], middle_point[2], color[1], color[2], color[3], color[4])
    end,
 
    shift = 0,
    shift_time = 0,
    shift_percent = 0,
    old_sim_time = 0,

    net_update_end = function(self) --For getting shifted ticks
        if lp == nil or entity_is_alive(lp) == false then
            return
        end
    
        local sim_time = entity_get_prop(lp, "m_flSimulationTime")
        if sim_time ~= nil then
            if self.old_sim_time ~= sim_time then
                self.shift = (sim_time/globals_tickinterval()) - globals_tickcount()
                self.old_sim_time = sim_time
            end
        end
    end,

    visual_body_angle = 0,
    visual_body_side = false,
    
    get_body_side = function(self)
        if lp == nil or entity.is_alive(lp) == false then
            return
        end
        local _, view = client.camera_angles()
        local yaw = shared_data.data and shared_data.data.abs or 0
        local body_angle = entity_get_prop(lp, "m_flPoseParameter", 11)

        if view == nil or yaw == nil or body_angle == nil then
            return
        end

        body_angle = (body_angle * 120) - 60

        local body_side = body_angle > 0
        local view_delta = math_fn.normalize_yaw(yaw - view)
        local view_abs_delta = math.abs(view_delta)

        if view_abs_delta > 90 then
            body_angle = -body_angle
            body_side = not body_side
        end

        if view_abs_delta > 60 and view_abs_delta < 120 then
            local side = view_delta < 0 
            local abs_body = math.abs(body_angle)
            self.visual_body_angle = side and abs_body or -abs_body
            self.visual_body_side = side
        else
            self.visual_body_angle = body_angle
            self.visual_body_side = body_side
        end
    end,

    run_command = function(self, cmd)
        self.shift_time = self.shift < 0 and self.shift_time + 1 or 0
    end,

    fade_shift = function(self)
        local shift_increase = (1 / 0.1) * globals_frametime()
        local shift_decrease = (1 / 0.075) * globals_frametime()

        if self.shift_time > 10 then
            self.shift_percent = self.shift_percent + shift_increase
        else
            self.shift_percent = self.shift_percent - shift_decrease
        end
        self.shift_percent = math_fn.clamp(0, 1, self.shift_percent)
    end,

    
    indicators_max_alpha = 0,

    update_indicator = function(self, cache_name, name, color, active, bar, bar_percent, bar_color, bar_color2)
        local found, pos = false, nil

        for i = 1, #self.indicators do
            local indicator = self.indicators[i]

            if indicator.cache_name == cache_name then
                pos = i
                found = true
                break
            end
        end

        if found then --update
            local old_indicator = self.indicators[pos]

            self.indicators[pos] = {
                cache_name = cache_name,
                name = active and name or old_indicator.name,
                color = color,
                active = active,
                bar = bar,
                bar_percent = bar_percent,
                bar_color = bar_color,
                bar_color2 = bar_color2,
                alpha = old_indicator.alpha,
                text_anim = old_indicator.text_anim,
                bar_anim = old_indicator.bar_anim
            }
        else --create
            self.indicators[#self.indicators + 1] = {
                cache_name = cache_name,
                name = name,
                color = color,
                active = active,
                bar = bar,
                bar_percent = bar_percent,
                bar_color = bar_color,
                bar_color2 = bar_color2,
                alpha = 0,
                text_anim = 0,
                bar_anim = 0
            }
        end
    end,

    update_animations = function(self, state, inc, dec)
        for i = 1, #self.indicators do 
            local indicator = self.indicators[i]

            if state then
                if indicator.active == false then
                    indicator.bar_anim = math_fn.clamp(0, 1, indicator.bar_anim - dec)

                    if indicator.bar_anim == 0 then
                        indicator.alpha = math_fn.clamp(0, 1, indicator.alpha - dec)
                        indicator.text_anim = math_fn.clamp(0, 1, indicator.text_anim - dec)
                    end
                else
                    indicator.alpha = math_fn.clamp(0, 1, indicator.alpha + inc)

                    if indicator.bar then
                        indicator.text_anim = math_fn.clamp(0, 1, indicator.text_anim + inc)

                        if indicator.text_anim == 1 then
                            indicator.bar_anim = math_fn.clamp(0, 1, indicator.bar_anim + inc)
                        else
                            indicator.bar_anim = 0
                        end
                    else
                        indicator.bar_anim = math_fn.clamp(0, 1, indicator.bar_anim - dec)

                        if indicator.bar_anim == 0 then
                            indicator.text_anim = math_fn.clamp(0, 1, indicator.text_anim - dec)
                        end
                    end
                end
            else
                indicator.alpha = math_fn.clamp(0, 1, indicator.alpha - dec)
                indicator.text_anim = math_fn.clamp(0, 1, indicator.text_anim - dec)
                indicator.bar_anim = math_fn.clamp(0, 1, indicator.bar_anim - dec)
            end
        end
    end,

    old_total_height = 14,
    old_width = 50,

    draw_indicators = function(self, color1, color2)
        local title_font = "b"
        local norm_font = "b"
        local uppercase = false
        local bar_size = 25
        local bar_height = 5

        local crosshair_style = gui:get_combo("Crosshair style", "Header style")
        local crosshair_text = gui:get_combo("Crosshair style", "Text style")
        local arrow_style = gui:get_combo("Crosshair style", "Arrow style")

        if crosshair_style == "Normal" then
            title_font = ""
        elseif crosshair_style == "Small" then
            uppercase = true
            title_font = "-"
        elseif crosshair_style == "Large" then
            title_font = "+"
        end

        if crosshair_text == "Normal" then
            norm_font = ""
        elseif crosshair_text == "Small" then
            norm_font = "-"
        end
        
        local offset = 35
        local _, view = client.camera_angles()
        local _, yaw = entity_get_prop(lp, "m_angRotation")

        local active_color = {color1[1], color1[2], color1[3], self.indicators_max_alpha * 255}
        local disabled_color = {get(menu.crosshair_color)}
        disabled_color[4] = disabled_color[4] * self.indicators_max_alpha
        local fake_color = {0, 0, 0, 125 * self.indicators_max_alpha}

        if arrow_style == "Manual side" then

            if side == "left" then
                self:draw_arrow(true, math_fn.normalize_yaw(view - 90), 50, disabled_color, disabled_color, 15)
                self:draw_arrow(true, math_fn.normalize_yaw(view + 90), 50, active_color, active_color, 15)
            elseif side == "right" then
                self:draw_arrow(true, math_fn.normalize_yaw(view - 90), 50, active_color, active_color, 15)
                self:draw_arrow(true, math_fn.normalize_yaw(view + 90), 50, disabled_color, disabled_color, 15)
            else
                self:draw_arrow(true, math_fn.normalize_yaw(view - 90), 50, disabled_color, disabled_color, 15)
                self:draw_arrow(true, math_fn.normalize_yaw(view + 90), 50, disabled_color, disabled_color, 15)
            end
        elseif arrow_style == "Body side" then
            if self.visual_body_side then
                self:draw_arrow(true, math_fn.normalize_yaw(view - 90), 50, active_color, active_color, 15)
                self:draw_arrow(true, math_fn.normalize_yaw(view + 90), 50, disabled_color, disabled_color, 15)
            else
                self:draw_arrow(true, math_fn.normalize_yaw(view - 90), 50, disabled_color, disabled_color, 15)
                self:draw_arrow(true, math_fn.normalize_yaw(view + 90), 50, active_color, active_color, 15)
            end
        elseif arrow_style == "Freestand arrow" then
            self:draw_arrow(true, shared_data.data and shared_data.data.fake or 0, 45, disabled_color, disabled_color, 15)
            self:draw_arrow(true, yaw, 45, active_color, active_color, 15)
            offset = 70
        end

        local title_text = self.indicators_title_text

        if type(self.indicators_title_text) == "string" then
            title_text = {self.indicators_title_text}
        end


        local title_color = shared_data.data and shared_data.data.antiaim_color or {255, 255, 255, 255}
        local title_color2 = shared_data.data and shared_data.data.antiaim_color2 or {255, 255, 255, 255}

        for i = 1, #title_text do
            local cur_text = uppercase and string.upper(title_text[i]) or title_text[i]
            local title_size = {renderer_measure_text(title_font, cur_text)}

            local title_x_offset = -title_size[1]/2
            local string_length = string.len(cur_text)

            for i = 1, string_length do
                local lerp = math_fn.lerp(title_color, title_color2, i / string_length)
                local char = string.sub(cur_text, i, i)
                local char_len = {renderer_measure_text(title_font, char)}

                renderer_text(center[1] + title_x_offset, center[2] + offset, lerp[1], lerp[2], lerp[3], self.indicators_max_alpha * lerp[4], title_font, 0, char)
                title_x_offset = title_x_offset + char_len[1]
            end
            offset = offset + title_size[2] + 3
        end

        local title_size = {renderer_measure_text(title_font, title_text[1] or "matrixllc.gay")}
        right_click.data.crosshair_style.pos = {center[1] - title_size[1]/2 - 5, center[2] + 30}
        right_click.data.crosshair_style.size = {title_size[1] + 10, 17}

        local total_height = 0
        local wanted_width = 50

        if title_size[1] + 4 > wanted_width then
            wanted_width = title_size[1] + 4
        end

        for i = 1, #self.indicators do
            local indicator = self.indicators[i]

            if indicator.alpha > 0 then
                local text_size = {renderer_measure_text(norm_font, indicator.name)}
                total_height = total_height + text_size[2] + 2
            end 
        end
        
        if total_height == 0 then   
            total_height = 14
        end

        if total_height < self.old_total_height then
            local rate = (50 / 0.4) * globals_frametime()
            self.old_total_height = math_fn.clamp(total_height, self.old_total_height, self.old_total_height - rate)
        else
            local rate = (50 / 0.4) * globals_frametime()
            self.old_total_height = math_fn.clamp(self.old_total_height, total_height, self.old_total_height + rate)
        end

        if wanted_width < self.old_width then
            local rate = (50 / 0.2) * globals_frametime()
            self.old_width = math_fn.clamp(wanted_width, self.old_width, self.old_width - rate)
        else
            local rate = (50 / 0.2) * globals_frametime()
            self.old_width = math_fn.clamp(self.old_width, wanted_width, self.old_width + rate)
        end
        
        local size = {self.old_width, 14}

        if shared_data.data and shared_data.data.crosshair_bar_percent then
            shared_data.data.crosshair_bar_percent = math_fn.clamp(0, 1, shared_data.data.crosshair_bar_percent)
            renderer_rectangle(center[1] - size[1]/2, center[2] + offset, size[1] + 1, 4, 25, 25, 25, self.indicators_max_alpha * 200)
            renderer_gradient(center[1] - size[1]/2 + 1, center[2] + offset + 1, (size[1] - 1) * shared_data.data.crosshair_bar_percent, 2, color1[1], color1[2], color1[3], self.indicators_max_alpha * 255, color2[1], color2[2], color2[3], self.indicators_max_alpha * 255, true)
            offset = offset + 6
        end

        local crosshair_options = gui:get_list("Crosshair style", "Options")

        if ui_fn.includes(crosshair_options, "Desync line") then
            local percent = self.visual_body_angle / 56
            percent = math_fn.clamp(-0.97, 1, percent)

            renderer_rectangle(center[1] - size[1]/2, center[2] + offset, size[1] + 1, 4, 25, 25, 25, self.indicators_max_alpha * 200)
            renderer_gradient(center[1], center[2] + offset + 1, (size[1] / 2) * percent, 2, color1[1], color1[2], color1[3], self.indicators_max_alpha * 255, color2[1], color2[2], color2[3], self.indicators_max_alpha * 255, true)
            offset = offset + 6
        end

        if ui_fn.includes(crosshair_options, "Gradient background") then
            renderer_gradient(center[1] - size[1]/2, center[2] + offset, size[1] + 1, self.old_total_height, 25, 25, 25, self.indicators_max_alpha * 125, 25, 25, 25, self.indicators_max_alpha * 25, false)
        end
        
        if ui_fn.includes(crosshair_options, "Gradient bar") then
            renderer_gradient(center[1] - size[1]/2, center[2] + offset, size[1], 1, color1[1], color1[2], color1[3], self.indicators_max_alpha * 255, color2[1], color2[2], color2[3], self.indicators_max_alpha * 255, true)
            renderer_gradient(center[1] - size[1]/2, center[2] + offset, 1, size[2] - 2, color1[1], color1[2], color1[3], self.indicators_max_alpha * 255, color1[1], color1[2], color1[3], 0, false)
            renderer_gradient(center[1] + size[1]/2, center[2] + offset, 1, size[2] - 2, color2[1], color2[2], color2[3], self.indicators_max_alpha * 255, color2[1], color2[2], color2[3], 0, false)
            offset = offset + 2
        end

        for i = 1, #self.indicators do
            local indicator = self.indicators[i]

            if indicator.alpha > 0 then
                local text_size = {renderer_measure_text(norm_font, indicator.name)}

                local color = indicator.color

                --clamp things
                indicator.alpha = math_fn.clamp(0, self.indicators_max_alpha, indicator.alpha)
                indicator.text_anim = math_fn.clamp(0, self.indicators_max_alpha, indicator.text_anim)
                indicator.bar_anim = math_fn.clamp(0, self.indicators_max_alpha, indicator.bar_anim)

                if indicator.bar or indicator.text_anim > 0 or indicator.bar_anim > 0 then
                    local bar_color = indicator.bar_color
                    local bar_color2 = math_fn.lerp(bar_color, indicator.bar_color2, indicator.bar_percent)

                    local bar_text_offset = bar_size/2 * indicator.text_anim
                    local fill_percent = math_fn.clamp(0, indicator.bar_anim, indicator.bar_percent)

                    --draw text
                    renderer_text(center[1] - text_size[1]/2 - bar_text_offset + (norm_font == "-" and -2 or 0), center[2] + offset, color[1], color[2], color[3], math_fn.clamp(0, indicator.alpha * 255, color[4]), norm_font, 0, indicator.name)

                    --draw
                    renderer_rectangle(center[1] + text_size[1]/2 + 2 - bar_size/2, center[2] + text_size[2]/3 + offset, bar_size * indicator.bar_anim, bar_height, 25, 25, 25, indicator.bar_anim * 100)
                    renderer_gradient(center[1] + text_size[1]/2 + 2 - bar_size/2 + 1, center[2] + text_size[2]/3 + offset + 1, math_fn.clamp(0, (bar_size - 2) * fill_percent, bar_size * fill_percent), bar_height - 2, bar_color[1], bar_color[2], bar_color[3], indicator.bar_anim * 255, bar_color2[1], bar_color2[2], bar_color2[3], indicator.bar_anim * 255, indicator.bar_anim * 255, true)
                else
                    renderer_text(center[1] - text_size[1]/2, center[2] + offset, color[1], color[2], color[3], math_fn.clamp(0, indicator.alpha * 255, color[4]), norm_font, 0, indicator.name)
                end

                offset = offset + text_size[2] + 2
            end
        end

        right_click.data.crosshair_style.size[2] = offset
    end,

    run = function(self)
        --clear data
        right_click.data.crosshair_style.pos = {nil, nil}
        right_click.data.crosshair_style.size = {nil, nil}

        self:get_body_side()
        self:fade_shift()

        local increase_rate = (1 / 0.1) * globals_frametime()
        local decrease_rate = (1 / 0.2) * globals_frametime()

        --Fade shit
        local crosshair_state = get(menu.enable) and get(menu.main_visuals) and ui_fn.includes(get(menu.visual_modes), "Crosshair")

        if crosshair_state == false then
            self.indicators_max_alpha = math_fn.clamp(0, 1, self.indicators_max_alpha - decrease_rate)
        else
            if lp ~= nil and entity_is_alive(lp) then
                self.indicators_max_alpha = math_fn.clamp(0, 1, self.indicators_max_alpha + decrease_rate)
            else
                self.indicators_max_alpha = math_fn.clamp(0, 1, self.indicators_max_alpha - decrease_rate)
            end
        end

        local disabled = {get(menu.crosshair_color)}

        self.indicators_title_text = shared_data.data and shared_data.data.antiaim_name or "void.dev"
        local crosshair_options_g = gui:get_list("Crosshair style", "Options")

        --create elements
        local dt_state = get(ref.doubletap[1]) and get(ref.doubletap[2])
        local os_state = get(ref.onshot[1]) and get(ref.onshot[2])
        local fb_state = get(ref.force_body_aim)
        local safe_state = get(ref.safe_point)
        local qp_state = get(ref.quick_peek[1]) and get(ref.quick_peek[2])
        local ps_state = get(ref.ping_spike[1]) and get(ref.ping_spike[2])
        local fake_flick = shared_data.data and shared_data.data.fake_flick

        if gui:get_combo("Crosshair style", "Only show when active") == "Only show when active" then
            self:update_indicator("dt", "DT", color1, ui_fn.includes(crosshair_options_g, "Double tap") and dt_state, dt_state, self.shift_percent, color1, color2)
            self:update_indicator("fk", "FF", color1, ui_fn.includes(crosshair_options_g, "Fake flick") and fake_flick, fake_flick, 1 - (shared_data.data and shared_data.data.fake_flick_cycle or 0), color1, color2)
            self:update_indicator("os", "OSAA", color1, ui_fn.includes(crosshair_options_g, "On shot anti-aim") and os_state, false, 0)
            self:update_indicator("ps", "PING", color1, ui_fn.includes(crosshair_options_g, "Ping spike") and ps_state, false, 0)
            self:update_indicator("fba", "BAIM", color1, ui_fn.includes(crosshair_options_g, "Force body aim") and fb_state, false, 0)
            self:update_indicator("sp", "SAFE", color1, ui_fn.includes(crosshair_options_g, "Force safe point") and safe_state, false, 0)
            self:update_indicator("qp", "PEEK", color1, ui_fn.includes(crosshair_options_g, "Quick peek") and qp_state, false, 0)
            self:update_indicator("fs", "YAW", color1, ui_fn.includes(crosshair_options_g, "Freestanding/Edge yaw") and f_stand_or_edge_yaw, false, 0)
        else
            local dt_lerp_color = math_fn.lerp(disabled, color1, self.shift_percent)
            self:update_indicator("dt", "DT", dt_lerp_color, ui_fn.includes(crosshair_options_g, "Double tap"), dt_state, self.shift_percent, color1, color2)
            self:update_indicator("fk", "FF", fake_flick and color1 or disabled, ui_fn.includes(crosshair_options_g, "Fake flick"), fake_flick, 1 - (shared_data.data and shared_data.data.fake_flick_cycle or 0), color1, color2)
            self:update_indicator("os", "OSAA", os_state and color1 or disabled, ui_fn.includes(crosshair_options_g, "On shot anti-aim"), false, 0)
            self:update_indicator("ps", "PING", ps_state and color1 or disabled, ui_fn.includes(crosshair_options_g, "Ping spike"), false, 0)
            self:update_indicator("fba", "BAIM", fb_state and color1 or disabled, ui_fn.includes(crosshair_options_g, "Force body aim"), false, 0)
            self:update_indicator("sp", "SAFE", safe_state and color1 or disabled, ui_fn.includes(crosshair_options_g, "Force safe point"), false, 0)
            self:update_indicator("qp", "PEEK", qp_state and color1 or disabled, ui_fn.includes(crosshair_options_g, "Quick peek"), false, 0)
            self:update_indicator("fs", "YAW", f_stand_or_edge_yaw and color1 or disabled, ui_fn.includes(crosshair_options_g, "Freestanding/Edge yaw"), false, 0)
        end

        self:update_animations(crosshair_state, increase_rate, decrease_rate)
        self:draw_indicators(color1, color2)

        if crosshair_state == false then
            right_click.data.crosshair_style.pos = {nil, nil}
            right_click.data.crosshair_style.size = {nil, nil}
        end
    end,
}
create_callback("net_update_end", function() crosshair:net_update_end() end)
create_callback("run_command", function() crosshair:run_command() end)
create_callback("paint", function() crosshair:run() end)

local main_visuals = {
    total_fps = {},
    averaged = 0,

    get_fps = function(self)
        local frametime = 1/globals_frametime()

        insert(self.total_fps, {
            fps = frametime,
            time = globals_realtime() + 1
        })

        while (#self.total_fps > 500) do
            remove(self.total_fps, #self.total_fps)
        end

        for i = #self.total_fps, 1, -1 do
            local frame = self.total_fps[i]

            if frame.time < globals_realtime() then
                remove(self.total_fps, i)
            end
        end

        local total = 0

        for i = 1, #self.total_fps do
            local frame = self.total_fps[i]

            total = total + frame.fps
        end

        self.averaged = total / #self.total_fps
    end,

    watermark = function(self)
        right_click.data.main_visuals.pos = {nil, nil}
        right_click.data.main_visuals.size = {nil, nil}

        if get(menu.enable) == false or get(menu.main_visuals) == false or ui_fn.includes(get(menu.visual_modes), "Watermark") == false then
            return
        end

        local flags = ""

        if gui:get_combo("Watermark", "Text style") == "Bold" then
            flags = "b"
        end

        --Get colors
        local white = {255, 255, 255, 255}

        local bar_width = 50
        local bar_height = 6

        local texts = {}
        local text_color = math_fn.lerp(color1, {255, 255, 255, 255}, 0.4)

        if lp ~= nil then
            local latency = math_floor(math_fn.clamp(0, 1000, client_latency() * 1000))
            local watermark_options_g = gui:get_list("Watermark", "Watermark options") 

            for i = 1, #watermark_options_g do
                if watermark_options_g[i] == "Spectator list" then
                    remove(watermark_options_g, i)
                end
            end

            local user, user_last = ui_fn.includes(watermark_options_g, "Username"), watermark_options_g[#watermark_options_g] == "Username"
            local tick, tick_last = ui_fn.includes(watermark_options_g, "Tickrate"), watermark_options_g[#watermark_options_g] == "Tickrate"
            local ping, ping_last = ui_fn.includes(watermark_options_g, "Ping"), watermark_options_g[#watermark_options_g] == "Ping"
            local fps, fps_last = ui_fn.includes(watermark_options_g, "Avg. fps"), watermark_options_g[#watermark_options_g] == "Avg. fps"

            if not tick then
                tick_last = true
            end

            if not ping then
                ping_last = true
            end

            if not fps then
                fps_last = true
            end
            
            texts = {
                {"VOID ", text_color},
                {"[", white},
                {(build or "undefined"), text_color},
                {"]", white},
                {#watermark_options_g == 0 and "" or " | ", white},

                {user and (username or "undefined") or "", text_color},
                {user and " [" or "", white},
                {user and (uid or "undefined") or "", text_color},
                {user and "]" or "", white},
                {user_last and "" or (user and " | " or ""), white},

                {tick and "Tickrate: " or "", white},
                {tick and tostring(1/globals_tickinterval()) or "", text_color},
                {tick_last and "" or " | ", white},

                {ping and "Ping: " or "", white},
                {ping and ( tostring(latency) .. (latency > 25 and " " or "") ) or "", text_color},
                (latency > 50 and ping) and {math_fn.clamp(0, 1, latency / 200), color1, color2} or {"", white},
                {ping_last and "" or " | ", white},

                {fps and "Avg. fps: " or "", white},
                (fps and self.averaged < 144) and {tostring(math_floor(self.averaged)) .. " ", text_color} or {"", white},
                fps and {math_fn.clamp(0, 1, self.averaged / 144), color1, color2} or {"", white}
            }
        else
            texts = {
                {"void ", text_color},
                {"[", white},
                {(build or "undefined"), text_color},
                {"]", white},
                {" | ", white},
                {username or "undefined", text_color},
                {" [", white},
                {uid or "undefined", text_color},
                {"] | Main menu", white}
            }
        end

        --measure size
        local total_size = 8
        local tallest_text = bar_height

        for i = 1, #texts do
            local text = texts[i]

            if type(text[1]) == "string" then
                local text_size = {renderer_measure_text(flags, text[1])}
                total_size = total_size + text_size[1]

                if tallest_text < text_size[2] then
                    tallest_text = text_size[2]
                end
            else
                total_size = total_size + bar_width + (i == #texts and 2 or 4)
            end
        end
        
        local size = {total_size + 1, tallest_text + 8}
        local pos = {screen[1] - size[1] - 5, 5}

        right_click.data.main_visuals.pos = pos
        right_click.data.main_visuals.size = size

        --Draw
        styles:background(gui:get_combo("Watermark", "Background style"), pos, size, color1, color2, get(menu.background_alpha))

        --Render text
        local offset = 4

        for i = 1, #texts do
            local text = texts[i]

            if type(text[1]) == "string" then
                local text_size = {renderer_measure_text(flags, text[1])}
                local color = text[2]

                renderer_text(pos[1] + offset, pos[2] + size[2]/2 - text_size[2]/2 - 1, color[1], color[2], color[3], 255, flags, 0, text[1])

                offset = offset + text_size[1]
            else
                local tcolor1 = text[2]
                local tcolor2 = text[3]

                local lerp_color = math_fn.lerp(tcolor1, tcolor2, text[1])

                renderer_rectangle(pos[1] + offset + 1, pos[2] + size[2] / 2 - bar_height/2, bar_width, bar_height, 15, 15, 15, 255)
                renderer_gradient(pos[1] + offset + 1, pos[2] + size[2] / 2 - bar_height/2, bar_width * text[1], bar_height, tcolor1[1], tcolor1[2], tcolor1[3], 255, lerp_color[1], lerp_color[2], lerp_color[3], 255, true)

                offset = offset + bar_width + (i == #texts and 2 or 4)
            end
        end
    end
}
create_callback("paint_ui", function() main_visuals:watermark() end)
create_callback("paint", function() main_visuals:get_fps() end)

local spectator = {
    players = {},
    alpha = 0,
    hotkey_dragging = false,
    hotkey_drag_delta = {0, 0},
    last_width = 120,

    init = function(self)
        for i = 1, 64 do
            self.players[i] = 0
        end
    end,

    handle_spectators = function(self)
        local spec_target = lp

        if entity_is_alive(spec_target) == false then
            local m_hObserverTarget = entity_get_prop(spec_target, "m_hObserverTarget")

            if entity.get_classname(m_hObserverTarget) == "CCSPlayer" then
                spec_target = m_hObserverTarget
            end
        end

        if spec_target == nil or entity_is_alive(spec_target) == false then
            for i = 1, #self.players do
                self.players[i] = 0
            end
            return
        end

        local increase_rate = (1 / 0.2) * globals_frametime()
        local decrease_rate = (1 / 0.5) * globals_frametime()

        for i = 1, #self.players do
            local m_hObserverTarget = entity_get_prop(i, "m_hObserverTarget")

            if m_hObserverTarget == spec_target and i ~= lp and entity.get_classname(i) == "CCSPlayer" and entity_is_alive(i) == false then
                self.players[i] = math_fn.clamp(0, 1, self.players[i] + increase_rate)
            else
                self.players[i] = math_fn.clamp(0, 1, self.players[i] - increase_rate) 
            end
        end
    end,

    run = function(self)
        right_click.data.spectator.pos = {nil, nil}
        right_click.data.spectator.size = {nil, nil}

        self:handle_spectators()

        local longest_text = 120
        local spec_flag = ""
        local active_players = 0

        if gui:get_combo("Spec", "Text style") == "Bold" then
            spec_flag = "b"
        end

        for i = 1, #self.players do 
            local alpha = self.players[i]

            if alpha > 0 then
                local name = entity_get_player_name(i)

                if name then
                    local m_fFlags = entity_get_prop(i, "m_fFlags")

                    if m_fFlags and bit.band(m_fFlags, 0x200) == 0x200 then --Bot check
                        name = name .. " (bot)"
                    end

                    local size = {renderer_measure_text(spec_flag, name)}

                    if size[1] > longest_text then
                        longest_text = size[1]
                    end

                    active_players = active_players + 1
                end
            end
        end

        if get(menu.enable) == false or get(menu.main_visuals) == false or ui_fn.includes(get(menu.visual_modes), "Spectator list") == false or lp == nil or (active_players == 0 and ui.is_menu_open() == false) then
            self.alpha = math.max(0, self.alpha - ((1 / 0.2) * globals_frametime()))
        else
            self.alpha = math.min(1, self.alpha + ((1 / 0.1) * globals_frametime()))
        end

        if self.alpha == 0 then
            return
        end

        --disable
        set(ref.spectator, false)

        local pos = {get(menu.spec_x), get(menu.spec_y)}
        local size = {120, 20}

        longest_text = longest_text + 4
        if self.last_width < longest_text then
            self.last_width = longest_text
        else
            local width_rate = (25 / 0.1) * globals_frametime()
            self.last_width = math_fn.clamp(longest_text, self.last_width, self.last_width - width_rate)
        end
        size[1] = self.last_width

        if ui_is_menu_open() and gui.active_dropdowns == false then
            local click = client_key_state(0x01)
            local mouse = {ui_mouse_position()}

            if self.hotkey_dragging and not click then
                self.hotkey_dragging = false
            end

            if self.hotkey_dragging and click then
                pos[1] = mouse[1] - self.hotkey_drag_delta[1]
                pos[2] = mouse[2] - self.hotkey_drag_delta[2]

                set(menu.spec_x, math_fn.clamp(0, screen[1] - size[1], pos[1])) --Saves to a slider
                set(menu.spec_y, math_fn.clamp(0, screen[2] - size[2], pos[2]))
            end
            if ui_fn.mouse_within(pos[1], pos[2], size[1], size[2]) and click then
                self.hotkey_dragging = true
                self.hotkey_drag_delta[1] = mouse[1] - pos[1]
                self.hotkey_drag_delta[2] = mouse[2] - pos[2]
            end
        end

        pos = {get(menu.spec_x), get(menu.spec_y)}

        --background
        local header_font = gui:get_combo("Spec", "Header style") == "Bold" and "b" or ""
        styles:background(gui:get_combo("Spec", "Background style"), pos, {size[1], 23}, color1, color2, math_fn.clamp(0, self.alpha * 255, get(menu.background_alpha)))
        local hotkey_size = {renderer_measure_text(header_font, "Spectators")}
        renderer_text(pos[1] + size[1]/2 - hotkey_size[1]/2, pos[2] + 12 - hotkey_size[2]/2, 255, 255, 255, self.alpha * 255, header_font, 0, "Spectators")


        right_click.data.spectator.pos = pos
        right_click.data.spectator.size = size

        local offset = size[2] + 4

        for i = 1, #self.players do 
            local alpha = self.players[i]

            if alpha > 0 then
                local name = entity_get_player_name(i)

                if name then
                    name = " - " .. name

                    local m_fFlags = entity_get_prop(i, "m_fFlags")
                    if m_fFlags and bit.band(m_fFlags, 0x200) == 0x200 then --Bot check
                        name = name .. " [bot]"
                    end

                    local text_size = {renderer_measure_text(spec_flag, name)}
                    renderer_text(pos[1] + 2, pos[2] + offset, 255, 255, 255, alpha * 255, spec_flag, 0, name)
                    offset = offset + text_size[2] + 2
                end
            end
        end
        if active_players > 0 then
            right_click.data.spectator.size = size
        end
    end,
}
create_callback("paint", function() spectator:run() end)
spectator:init()

local hotkey = {
    hotkeys = {},
    background_alpha = 0,
    last_hotkey_width = 25,
    hotkey_dragging = false,
    hotkey_drag_delta = {0, 0},

    sliders_g = {},
    
    hotkey_state_names = {
        "Always on",
        "On hotkey",
        "Toggle",
        "Off hotkey"
    },
    
    get_hotkey_state = function(self, hotkey)
        local hotkey_g = {get(hotkey)}
        return "[" .. self.hotkey_state_names[hotkey_g[2] + 1] .. "]"
    end,

    create = function(self, name, func)
        table.insert(self.hotkeys, {
            name = name,
            alpha = 0,
            func = func, --return state, toggle name, slider percent (can be nil)
        })
    end,

    init = function(self)
        --hotkeys
        self:create("Double tap", function()
            return ui_fn.includes(self.sliders_g, "Double tap") and get(ref.doubletap[1]) and get(ref.doubletap[2]), nil, crosshair.shift_percent
        end)

        self:create("Fake lag", function()
            return ui_fn.includes(self.sliders_g, "Fake lag"), nil, globals.chokedcommands() / 14
        end)

        self:create("Lag comp", function()
            local data = shared_data.data

            if data then
                return ui_fn.includes(self.sliders_g, "Lag compensation") and data.ground_time < 8, nil, data.lc
            else
                return false, nil, nil
            end
        end)

        self:create("Bomb timer", function()
            if ui_fn.includes(self.sliders_g, "Bomb timer") == false then
                return false, nil, 0
            end

            local bombs = entity.get_all("CPlantedC4")

            if #bombs == 0 then
                return false, nil, 0
            end

            local bomb = bombs[1]

            if bomb == nil then
                return false, nil, 0
            end

            local site = entity_get_prop(bomb, "m_nBombSite")
            local time_left = entity_get_prop(bomb, "m_flC4Blow") - globals.curtime()

            if time_left <= 0 then
                return false, nil, 0
            end

            local defused = entity_get_prop(bomb, "m_bBombDefused")

            if defused == 1 then
                return false, nil, 0
            end

            local defuse_length = entity_get_prop(bomb, "m_flDefuseLength")
            local site_string = site == 1 and "B" or "A"

            if defuse_length > 0 then
                local defuse_time_left = entity_get_prop(bomb, "m_flDefuseCountDown") - globals.curtime()

                if defuse_time_left > 0 then
                    local has_defuser = entity_get_prop(bomb, "m_hBombDefuser")
                    if has_defuser ~= nil then
                        local percent = math_fn.clamp(0, 1, defuse_time_left / (has_defuser and 5 or 10))

                        if defuse_time_left > time_left then
                            return true, nil, percent, "Defuse: " .. site_string .. " - " .. "No time"
                        else
                            return true, nil, percent, "Defuse: " .. site_string .. " - " .. string.format("%.1fs", defuse_time_left)
                        end
                    end
                end
            end

            local max_bomb_time = cvar.mp_c4timer:get_int()
            local percent = math_fn.clamp(0, 1, time_left / max_bomb_time)

            return true, nil, percent, "Bomb: " .. site_string .. " - " .. string.format("%.1fs", time_left)
        end)

        self:create("Double tap", function()
            return ui_fn.includes(self.sliders_g, "Double tap") == false and get(ref.doubletap[1]) and get(ref.doubletap[2]), self:get_hotkey_state(ref.doubletap[2])
        end)

        self:create("On shot anti-aim", function()
            return get(ref.onshot[1]) and get(ref.onshot[2]), get(ref.onshot[1]) and self:get_hotkey_state(ref.onshot[2]) or ""
        end)

        self:create("Quick peek assist", function()
            return get(ref.quick_peek[2]), self:get_hotkey_state(ref.quick_peek[2]) or ""
        end)

        self:create("Duck peek assist", function()
            return get(ref.fakeduck), self:get_hotkey_state(ref.fakeduck)
        end)

        self:create("Force safe point", function()
            return get(ref.safe_point), self:get_hotkey_state(ref.safe_point)
        end)

        self:create("Force body aim", function()
            return get(ref.force_body_aim), self:get_hotkey_state(ref.force_body_aim)
        end)

        --self:create("Fake flick", function()
        --    if shared_data.data then
        --        return shared_data.data.fake_flick, self:get_hotkey_state(shared_data.data.menu.fake_flick_hotkey)
        --    else
        --        return false, nil, 1
        --    end
        --end)
    end,

    update_alpha = function(self, state)
        local increase_rate = (1 / 0.1) * globals_frametime()
        local decrease_rate = (1 / 0.2) * globals_frametime() 
        local hotkey_active = false

        self.sliders_g = gui:get_list("Hotkey", "Hotkey options")

        for i = 1, #self.hotkeys do
            local hotkey = self.hotkeys[i]

            if state == false then
                hotkey.alpha = math_fn.clamp(0, 1, hotkey.alpha - decrease_rate)
            else
                local hotkey_state, state2, slider, name = hotkey.func()

                if state2 == "[Off hotkey]" then
                    hotkey_state = not hotkey_state
                end

                if hotkey_state and state2 ~= "[Always on]" then
                    hotkey.alpha = math_fn.clamp(0, 1, hotkey.alpha + increase_rate)
                else
                    hotkey.alpha = math_fn.clamp(0, 1, hotkey.alpha - decrease_rate)
                end

                if hotkey.alpha > 0 then
                    hotkey_active = true
                end

                if name ~= nil then
                    hotkey.name = name
                end
            end
        end

        if state and (hotkey_active or ui_is_menu_open()) then
            self.background_alpha = math_fn.clamp(0, 1, self.background_alpha + increase_rate)
        else
            self.background_alpha = math_fn.clamp(0, 1, self.background_alpha - decrease_rate)
        end
    end,

    paint = function(self)
        local global_state = get(menu.enable) and get(menu.main_visuals) and ui_fn.includes(get(menu.visual_modes), "Hotkey list") and lp ~= nil and entity_is_alive(lp)

        self:update_alpha(global_state)

        right_click.data.hotkey.pos = {nil, nil}
        right_click.data.hotkey.size = {nil, nil}

        if self.background_alpha == 0 then
            return
        end

        local font = ""
        local header_font = ""

        if gui:get_combo("Hotkey", "Text style") == "Bold" then
            font = "b"
        end

        if gui:get_combo("Hotkey", "Header style") == "Bold" then
            header_font = "b"
        end

        local pos = {get(menu.hotkey_x), get(menu.hotkey_y)}
        local size = {120, 25}
        local slider_height = 6
        local longest_text = 0

        for i = 1, #self.hotkeys do
            local hotkey = self.hotkeys[i]

            if hotkey.alpha > 0 then
                local active, state, slider = hotkey.func()
                
                local hotkey_size = {}
                local text_size = {renderer.measure_text(font, hotkey.name)}

                if slider ~= nil then
                    hotkey_size = {text_size[1] + 50, 12}
                
                    if longest_text < text_size[1] then
                        longest_text = text_size[1]
                    end
                else
                    local state_size = {renderer.measure_text(font, state)}
                    hotkey_size = {text_size[1] + state_size[1] + 12, state_size[2] + 2}
                end

                if size[1] < hotkey_size[1] then
                    size[1] = hotkey_size[1]
                end

                size[2] = size[2] + hotkey_size[2]
            end
        end

        if ui_is_menu_open() and gui.active_dropdowns == false then
            local click = client_key_state(0x01)
            local mouse = {ui_mouse_position()}

            if self.hotkey_dragging and not click then
                self.hotkey_dragging = false
            end

            if self.hotkey_dragging and click then
                pos[1] = mouse[1] - self.hotkey_drag_delta[1]
                pos[2] = mouse[2] - self.hotkey_drag_delta[2]
                set(menu.hotkey_x, math_fn.clamp(0, screen[1] - size[1], pos[1])) --Saves to a slider
                set(menu.hotkey_y, math_fn.clamp(0, screen[2] - size[2], pos[2]))
            end
            if ui_fn.mouse_within(pos[1], pos[2], size[1], size[2]) and click then
                self.hotkey_dragging = true
                self.hotkey_drag_delta[1] = mouse[1] - pos[1]
                self.hotkey_drag_delta[2] = mouse[2] - pos[2]
            end
        end

        --update pos (so it doesn't drag behind your mouse)
        pos = {get(menu.hotkey_x), get(menu.hotkey_y)}

        --add padding
        size[1] = size[1] + 6
        
        if self.last_hotkey_width < size[1] then
            self.last_hotkey_width = size[1]
        else
            local width_rate = (25 / 0.1) * globals_frametime()
            self.last_hotkey_width = math_fn.clamp(size[1], self.last_hotkey_width, self.last_hotkey_width - width_rate)
        end
        size[1] = self.last_hotkey_width

        styles:background(gui:get_combo("Hotkey", "Background style"), pos, {size[1], 23}, color1, color2, math_fn.clamp(0, self.background_alpha * 255, get(menu.background_alpha)))
        local hotkey_size = {renderer_measure_text(header_font, "Indicators")}
        renderer_text(pos[1] + size[1]/2 - hotkey_size[1]/2, pos[2] + 12 - hotkey_size[2]/2, 255, 255, 255, self.background_alpha * 255, header_font, 0, "Indicators")

        local offset = 24

        for i = 1, #self.hotkeys do
            local hotkey = self.hotkeys[i]

            
            if hotkey.alpha > 0 then
                local active, state, slider = hotkey.func()

                local state_size = {renderer.measure_text(font, state)}

                if state == "[Off hotkey]" then
                    active = not active
                end

                local x_add = (1 - hotkey.alpha) * ((active and global_state) and -15 or 10)

                if slider ~= nil then
                    local text_size = {renderer.measure_text(font, hotkey.name)}
                    local width = size[1] - longest_text - 9 - 3
                    slider = math_fn.clamp(0, 1, slider)

                    local new_color2 = math_fn.lerp(color1, color2, slider)
                    renderer_text(pos[1] + 3 + x_add, pos[2] + offset - 6 + text_size[2]/2, 255, 255, 255, hotkey.alpha * 255, font, 0, hotkey.name)
                    renderer.rectangle(pos[1] + longest_text + 8 + x_add, pos[2] + offset + 6 - slider_height/2, width, slider_height + 2, 25, 25, 25, hotkey.alpha * 255)
                    renderer.gradient(pos[1] + longest_text + 9 + x_add, pos[2] + offset + 6 - slider_height/2 + 1, (width - 2) * slider, slider_height, color1[1], color1[2], color1[3], hotkey.alpha * 255, new_color2[1], new_color2[2], new_color2[3], hotkey.alpha * 255, true)

                    offset = offset + state_size[2] + 2
                else
                    renderer_text(pos[1] + 3 + x_add, pos[2] + offset + 1, 255, 255, 255, hotkey.alpha * 255, font, 0, hotkey.name)
                    renderer_text(pos[1] + size[1] - state_size[1] - 3 + x_add, pos[2] + offset + 1, 255, 255, 255, hotkey.alpha * 255, font, 0, state)

                    offset = offset + state_size[2] + 2
                end
            end
        end

        right_click.data.hotkey.pos = pos
        right_click.data.hotkey.size = size
    end
}
create_callback("paint_ui", function() hotkey:paint() end)
hotkey:init()
--[[
local resolver = {
    alpha = 0,
    resolver_dragging = false,
    resolver_drag_delta = {0, 0},

    run = function(self)
        local visual_modes_g = get(menu.visual_modes)
        local resolver_data = shared_data.resolv_data

        if ui_fn.includes(visual_modes_g, "Resolver") and lp and entity.is_alive(lp) and resolver_data and resolver_data.enable then
            self.alpha = self.alpha + (255 / 0.5) * globals.frametime()
        else
            self.alpha = self.alpha - (255 / 0.3) * globals.frametime()
        end
        self.alpha = math_fn.clamp(0, 255, self.alpha)

        if self.alpha > 0 then
            local font = (gui:get_combo("Resolver", "Text style") == "Bold") and "b" or ""
            local pos = {get(menu.resolver_x), get(menu.resolver_y)}
            local background_alpha = math_fn.clamp(0, get(menu.background_alpha), self.alpha)
            local style = gui:get_combo("Resolver", "Background style")
            local sliders = {}

            local title_text = "Matrix resolver | General accuracy: " .. math_floor(resolver_data.accuracy * 100) .. "% | Resolver accuracy: " .. math_floor(resolver_data.resolver_acc * 100) .. "%"
            local title_size = {renderer.measure_text(font, title_text)}

            local size = {title_size[1], title_size[2]}

            if ui_is_menu_open() and gui.active_dropdowns == false then
                local click = client_key_state(0x01)
                local mouse = {ui_mouse_position()}
    
                if self.resolver_dragging and not click then
                    self.resolver_dragging = false
                end
    
                if self.resolver_dragging and click then
                    pos[1] = mouse[1] - self.resolver_drag_delta[1]
                    pos[2] = mouse[2] - self.resolver_drag_delta[2]
                    set(menu.resolver_x, math_fn.clamp(0, screen[1] - size[1], pos[1])) --Saves to a slider
                    set(menu.resolver_y, math_fn.clamp(0, screen[2] - size[2], pos[2]))
                end
                if ui_fn.mouse_within(pos[1], pos[2], size[1], size[2]) and click then
                    self.resolver_dragging = true
                    self.resolver_drag_delta[1] = mouse[1] - pos[1]  
                    self.resolver_drag_delta[2] = mouse[2] - pos[2]
                end
            end
            pos = {get(menu.resolver_x), get(menu.resolver_y)}

            right_click.data.resolver.pos = pos
            right_click.data.resolver.size = size

            --Background
            styles:background(style, {pos[1] - 4, pos[2] - 4}, {size[1] + 8, size[2] + 8}, color1, color2, background_alpha)
            renderer_text(pos[1], pos[2], 255, 255, 255, self.alpha, font, (size[1] + 8) * (self.alpha / 200), title_text)

        else
            right_click.data.resolver.pos = {nil, nil}
            right_click.data.resolver.size = {nil, nil}
        end
    end,
}
create_callback("paint", function() resolver:run() end)
]]

local clantag = {
    last_tag = "",

    stages = {
        "",
        "",
        "f",
        "fo",
        "fem",
        "femb",
        "fembo",
        "femboy",
        "femboy.d",
        "femboy.de",
        "femboy.dev",
        "femboy.dev",
        "femboy.dev",
        "femboy.dev",
        "femboy.dev",
        "femboy.de",
        "femboy.d",
        "femboy",
        "fembo",
        "femb.",
        "fem",
        "fe",
        "f",
        "f",
        "",
        ""
    },

    run = function(self)
        local state = get(menu.clantag)
        
        if state == false then
            if self.last_tag ~= "" then
                client_set_clan_tag("")

                self.last_tag = ""
            end
            return
        end

        --tag shit
        local tag_int = math_floor(((globals_tickcount() * 0.045) % #self.stages) + 1)
        local tag_padding = "\t\t  "
        local matrix_tag = tag_padding .. self.stages[tag_int] .. tag_padding

        --default to ot
        local wish_tag = "legendware"

        --good kdr
        local resource = entity.get_player_resource()
        if resource ~= nil and lp ~= nil then
            local kills = entity_get_prop(resource, "m_iKills", lp) or 1
            local deaths = entity_get_prop(resource, "m_iDeaths", lp) or 0

            --fix kill count
            kills = (kills == 0 and deaths == 0) and 1 or kills

            if (kills/deaths) >= 0.75 then
                wish_tag = matrix_tag
            end
        end

        --clip
        if lp ~= nil and entity_is_alive(lp) then
            local m_iNumRoundKills = entity_get_prop(lp, "m_iNumRoundKills") or 0

            if m_iNumRoundKills ~= nil and m_iNumRoundKills >= 5 then
                wish_tag = matrix_tag
            end
        end

        if wish_tag ~= self.last_tag then
            client_set_clan_tag(wish_tag)
            self.last_tag = wish_tag
        end
    end,   
    
    shutdown = function(self)
        if self.last_tag ~= "" then
            client_set_clan_tag("")
        end
    end,
}
create_callback("paint", function() clantag:run() end)
create_callback("shutdown", function() clantag:shutdown() end)

local firework = {
    objects = {},
    total = 0,

    create = function(self, player, origin, angle, color, leading_speed, trailing_speed)
        insert(self.objects, {
            id = self.total + 1,
            player = player,
            origin = origin,
            position = nil,
            angle = angle,
            color = color,

            leading_animation = 0,
            leading_speed = leading_speed,

            trailing_animation = 0,
            trailing_speed = trailing_speed,
        })
    end,

    draw_segmented_line = function(from, dest, color, end_color, step)
        step = step or 4 
        
        for i = 100 - step, 0, -step do
            local current = i / 100
            local next = (i + step) / 100

            local xy_current = math_fn.lerp(from, dest, current)
            local xy_next = math_fn.lerp(from, dest, next)
            local color_lerp = math_fn.lerp(color, end_color, current)

            local average_point = {
                xy_current[1] + xy_next[1] / 2,
                xy_current[2] + xy_next[2] / 2,
                xy_current[3] + xy_next[3] / 2,
            }

            local w2s_current = {renderer_world_to_screen(xy_current[1], xy_current[2], xy_current[3])}
            local w2s_next = {renderer_world_to_screen(xy_next[1], xy_next[2], xy_next[3])}

            if w2s_current[1] and w2s_next[1] then
                renderer_line(w2s_current[1], w2s_current[2], w2s_next[1], w2s_next[2], color_lerp[1], color_lerp[2], color_lerp[3], color_lerp[4])
            else
                break
            end
        end
    end,

    --[[
    reflect = function(self, player, start_point, first_end_point, distance, fraction, angle)
        local angle3 = {angle[1] - 0.01, angle[2] - 0.01}
        local forward3 = math_fn.angle_forward(angle3)

        local pos3 = { 
            start_point[1] + (forward3[1] * distance),
            start_point[2] + (forward3[2] * distance),
            start_point[3] + (forward3[3] * distance)
        }

        local trace3 = {client_trace_line(player, start_point[1], start_point[2], start_point[3], pos3[1], pos3[2], pos3[3])}

        local vis3 = { 
            start_point[1] + (forward3[1] * distance * trace3[1]),
            start_point[2] + (forward3[2] * distance * trace3[1]),
            start_point[3] + (forward3[3] * distance  * trace3[1])
        }

        local wall_angle = math_fn.calc_angle(first_end_point, vis3)
        local viewangle = math_fn.calc_angle(start_point, first_end_point)

        local delta = {viewangle[1] - wall_angle[1], viewangle[2] - wall_angle[2]}

        wall_angle = {
            wall_angle[1] - delta[1],
            wall_angle[2] - delta[2],
        }
    
        local fov = math_fn:fov(start_point, first_end_point, wall_angle)

        local forward4 = math_fn.angle_forward(wall_angle)

        local pos4 = { 
            first_end_point[1] + (forward4[1] * distance),
            first_end_point[2] + (forward4[2] * distance),
            first_end_point[3] + (forward4[3] * distance)
        }

        local trace4 = {client_trace_line(player, first_end_point[1], first_end_point[2], first_end_point[3], pos4[1], pos4[2], pos4[3])}

        local vis4 = { 
            first_end_point[1] + (forward4[1] * distance * trace4[1]),
            first_end_point[2] + (forward4[2] * distance * trace4[1]),
            first_end_point[3] + (forward4[3] * distance * trace4[1])
        }
        
        return vis4
    end,
    ]]

    update = function(self)
        if get(menu.fireworks) == false or lp == nil then
            self.objects = {}
            return
        end

        local fps_saver = get(menu.fps_saver)
        local size = get(menu.firework_size)
        local distance = 0

        if size == "Large" then
            distance = 1000
        elseif size == "Medium" then
            distance = 100
        elseif size == "Small" then
            distance = 25
        end
        
        local frametime = globals_frametime()
        local update_this_tick = globals_framecount() % 2 == 0        

        local newest_id = self.objects[#self.objects] and self.objects[#self.objects].id or 0

        if get(menu.firework_limit) ~= 5 then
            for i = #self.objects, 1, -1 do
                if i <= #self.objects then
                    local object = self.objects[i]

                    local id_delta = math.abs(newest_id - object.id)

                    if id_delta >= get(menu.firework_limit) then
                        remove(self.objects, i)
                    end
                end
            end
        end

        local first_col = math_fn:rainbow(15, 0, 80, 50, 255)
        local second_col = math_fn:rainbow(15, 60, 80, 100, 255)

        if get(menu.firework_color) == "Custom" then
            first_col = {get(menu.firework_color1)}
            second_col = {get(menu.firework_color2)}
        end

        for i = 1, #self.objects do
            if i <= #self.objects then
                local object = self.objects[i]

                if object.leading_animation ~= 1 then
                    object.leading_animation = math_fn.clamp(0, 1, object.leading_animation + ((1 / object.leading_speed) * frametime))
                else
                    object.trailing_animation = math_fn.clamp(0, 1, object.trailing_animation + ((1 / object.trailing_speed) * frametime))
                end

                if object.position == nil then
                    local forward = math_fn.angle_forward(object.angle)

                    object.position = { 
                        object.origin[1] + (forward[1] * distance),
                        object.origin[2] + (forward[2] * distance),
                        object.origin[3] + (forward[3] * distance)
                    }

                    local trace = {client_trace_line(object.player, object.origin[1], object.origin[2], object.origin[3], object.position[1], object.position[2], object.position[3])}
                    
                    --Visible only
                    object.position = { 
                        object.origin[1] + (forward[1] * distance * trace[1]),
                        object.origin[2] + (forward[2] * distance * trace[1]),
                        object.origin[3] + (forward[3] * distance  * trace[1])
                    }
                end

                local trailing_origin = math_fn.lerp(object.origin, object.position, object.trailing_animation)
                local leading_origin = math_fn.lerp(object.origin, object.position, object.leading_animation)

                if fps_saver then
                    self.draw_segmented_line(trailing_origin, leading_origin, first_col, second_col, 25)
                else
                    self.draw_segmented_line(trailing_origin, leading_origin, first_col, second_col, 15)
                end

                if object.trailing_animation == 1 then
                    remove(self.objects, i)
                end
            end
        end
    end,

    pitch_offset = 30, 
    yaw_offset = 60,

    normalize_angle = function(self, angle)
        while angle[2] > 180 do
            angle[2] = angle[2] - 360
        end

        return angle
    end,

    aim_fire = function(self, e)
        local hit = {e.x, e.y, e.z}

        local anim = (100 - get(menu.firework_speed)) / 50
        local fps_saver = get(menu.fps_saver)

        self.yaw_offset = self.yaw_offset + 15

        for p = -90, 90, fps_saver and 45 or 30 do
            for i = -180, 180, fps_saver and 90 or 60 do
                self:create(e.target, hit, self:normalize_angle({p, i + self.yaw_offset}), {255, 0, 0, 255}, 0.3 * anim, 0.4 * anim)
            end
        end

        if self.yaw_offset > 360 then
            self.yaw_offset = 0
        end

        self.total = self.total + 1
    end,
}
create_callback("paint_ui", function() firework:update() end)
create_callback("aim_fire", function(e) firework:aim_fire(e) end)

local explosion = {
    objects = {},
    total = 0,

    create = function(self, origin, start_angle, abs_velocity, color, life)
        insert(self.objects, {
            id = self.total + 1,
            origin = origin,
            angle = start_angle,
            velocity = abs_velocity,
            color = color,
            time = globals_realtime() + life,
            alpha = 0
        })
    end,

    think = function(self, gravity)
        local frametime = globals_frametime()
        local gravity_speed = gravity and ( (180 / 1) * frametime) or 0
        local inc_speed = (255 / 0.5) * frametime
        local fade_speed = (255 / 1) * frametime

        local fps_saver = get(menu.fps_saver)
        local update_this_tick = fps_saver and (globals_framecount() % 3 == 0) or true

        for i = 1, #self.objects do
            if i <= #self.objects then
                local object = self.objects[i]

                local speed_this_tick = frametime * object.velocity

                --gravity
                object.angle[1] = math_fn.clamp(-90, 90, object.angle[1] + gravity_speed)


                if update_this_tick then
                    local forward = math_fn.angle_forward(object.angle)
                    local multiplied_forawrd = {forward[1] * speed_this_tick, forward[2] * speed_this_tick, forward[3] * speed_this_tick}

                    local last_origin = object.origin
                    local new_origin = {
                        object.origin[1] + multiplied_forawrd[1],
                        object.origin[2] + multiplied_forawrd[2],
                        object.origin[3] + multiplied_forawrd[3]
                    }

                    local trace = {client_trace_line(lp, last_origin[1], last_origin[2], last_origin[3], new_origin[1], new_origin[2], new_origin[3])}
                    if trace[1] ~= 0 then
                        object.origin = math_fn.lerp(last_origin, new_origin, trace[1])
                    end
                end

                if (object.time > globals_realtime()) then
                    object.alpha = math_fn.clamp(0, 255, object.alpha + inc_speed)
                else
                    object.alpha = math_fn.clamp(0, 255, object.alpha - fade_speed)

                    if object.alpha == 0 then
                        remove(self.objects, i)
                    end
                end
            end
        end
    end,

    draw = function(self)
        if get(menu.explosion) == false or lp == nil then
            self.objects = {}
            return
        end

        local newest_id = self.objects[#self.objects] and self.objects[#self.objects].id or 0

        if get(menu.explosion_limit) ~= 5 then
            for i = #self.objects, 1, -1 do
                if i <= #self.objects then
                    local object = self.objects[i]
                    local id_delta = math.abs(newest_id - object.id)

                    if id_delta >= get(menu.explosion_limit) then
                        remove(self.objects, i)
                    end
                end
            end
        end

        self:think(false)

        for i = 1, #self.objects do
            local object = self.objects[i]

            local x, y = renderer_world_to_screen(object.origin[1], object.origin[2], object.origin[3])

            if x and y then
                renderer_circle(x, y, object.color[1], object.color[2], object.color[3], object.alpha, 2, 1, 1)
            end
        end
    end,

    death = function(self, e)
        local index = client.userid_to_entindex(e.attacker)
        local vict = client.userid_to_entindex(e.userid)

        if index ~= lp or vict == lp then
            return
        end

        local explosion_speed_g = get(menu.explosion_speed) / 100
        local fps_saver = get(menu.fps_saver)

        for p = -90, 30, fps_saver and 23 or 10 do
            for i = -180, 180, p == -90 and 90 or math.random(10, 25) do
                local randomness = math.random(50, 300) * explosion_speed_g
                local random_percent = (randomness / (300 * explosion_speed_g))

                local color = math_fn.lerp({get(menu.explosion_color)}, {get(menu.explosion_color2)}, random_percent)
                self:create({entity.hitbox_position(vict, 5)}, {p, i}, randomness, color, math.random(0.5, 1.5))
            end
        end
        self.total = self.total + 1
    end
}
create_callback("paint_ui", function() explosion:draw() gui:run() end)
create_callback("player_death", function(e) explosion:death(e) end)
create_callback("setup_command", function(cmd) gui:setup_command(cmd) end)

local debug_testing = {
    reset_gui = function()
        if lp ~= nil and entity_is_alive(lp) and get(menu.gui_reset) then
            local size = {120, 20}
            local pos = {104, 40}
            set(menu.spec_x, math_fn.clamp(0, screen[1] - size[1], pos[1]))
        else
            return
        end
    end
}

create_callback("paint", function() debug_testing:reset_gui() end)

--Init. callbacks
for i = 1, #callbacks do
    local callback = callbacks[i]
    client_set_event_callback(callback.e, callback.f)
end

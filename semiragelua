local client_register_esp_flag, contains, client_scale_damage, client_trace_bullet, entity_get_game_rules, client_latency, client_log, client_draw_rectangle, client_draw_circle_outline, client_userid_to_entindex, client_draw_indicator, client_draw_gradient, client_set_event_callback, client_screen_size, client_eye_position = client.latency, client.log, client.draw_rectangle, client.draw_circle_outline, client.userid_to_entindex, client.draw_indicator, client.draw_gradient, client.set_event_callback, client.screen_size, client.eye_position
client_draw_circle, client_color_log, client_delay_call, client_draw_text, client_visible, client_exec, client_trace_line, client_set_cvar = client.draw_circle, client.color_log, client.delay_call, client.draw_text, client.visible, client.exec, client.trace_line, client.set_cvar
client_world_to_screen, client_draw_hitboxes, client_get_cvar, client_draw_line, client_camera_angles, client_draw_debug_text, client_random_int, client_random_float = client.world_to_screen, client.draw_hitboxes, client.get_cvar, client.draw_line, client.camera_angles, client.draw_debug_text, client.random_int, client.random_float
entity_get_local_player, entity_is_enemy, entity_hitbox_position, entity_get_player_name, entity_get_steam64, entity_get_bounding_box, entity_get_all, entity_set_prop = entity.get_local_player, entity.is_enemy, entity.hitbox_position, entity.get_player_name, entity.get_steam64, entity.get_bounding_box, entity.get_all, entity.set_prop
entity_is_alive, entity_get_player_weapon, entity_get_prop, entity_get_players, entity_get_classname = entity.is_alive, entity.get_player_weapon, entity.get_prop, entity.get_players, entity.get_classname
globals_realtime, globals_absoluteframetime, globals_tickcount, globals_curtime, globals_mapname, globals_tickinterval, globals_framecount, globals_frametime, globals_maxplayers = globals.realtime, globals.absoluteframetime, globals.tickcount, globals.curtime, globals.mapname, globals.tickinterval, globals.framecount, globals.frametime, globals.maxplayers
ui_new_slider, ui_new_combobox, ui_reference, ui_set_visible, ui_is_menu_open, ui_new_color_picker, ui_set_callback, ui_set, ui_new_checkbox, ui_new_hotkey, ui_new_button, ui_new_multiselect, ui_get = ui.new_slider, ui.new_combobox, ui.reference, ui.set_visible, ui.is_menu_open, ui.new_color_picker, ui.set_callback, ui.set, ui.new_checkbox, ui.new_hotkey, ui.new_button, ui.new_multiselect, ui.get
math_ceil, math_tan, math_log10, math_randomseed, math_cos, math_sinh, math_random, math_huge, math_pi, math_max, math_atan2, math_ldexp, math_floor, math_sqrt, math_deg, math_atan, math_fmod = math.ceil, math.tan, math.log10, math.randomseed, math.cos, math.sinh, math.random, math.huge, math.pi, math.max, math.atan2, math.ldexp, math.floor, math.sqrt, math.deg, math.atan, math.fmod
math_acos, math_pow, math_abs, math_min, math_sin, math_frexp, math_log, math_tanh, math_exp, math_modf, math_cosh, math_asin, math_rad = math.acos, math.pow, math.abs, math.min, math.sin, math.frexp, math.log, math.tanh, math.exp, math.modf, math.cosh, math.asin, math.rad
table_maxn, table_foreach, table_sort, table_remove, table_foreachi, table_move, table_getn, table_concat, table_insert = table.maxn, table.foreach, table.sort, table.remove, table.foreachi, table.move, table.getn, table.concat, table.insert
string_find, string_format, string_rep, string_gsub, string_len, string_gmatch, string_dump, string_match, string_reverse, string_byte, string_char, string_upper, string_lower, string_sub = string.find, string.format, string.rep, string.gsub, string.len, string.gmatch, string.dump, string.match, string.reverse, string.byte, string.char, string.upper, string.lower, string.sub
bit_band, client_delay_call, client_set_event_callback, entity_get_local_player, entity_get_player_weapon, entity_get_prop, print, func, select, table_insert, table_sort, type, ui_get, ui_name, ui_new_checkbox, ui_new_combobox, ui_new_multiselect, ui_reference, ui_set, ui_set_callback, ui_set_visible, xpcall, pairs = bit.band, client.delay_call, client.set_event_callback, entity.get_local_player, entity.get_player_weapon, entity.get_prop, print, func, select, table.insert, table.sort, type, ui.get, ui.name, ui.new_checkbox, ui.new_combobox, ui.new_multiselect, ui.reference, ui.set, ui.set_callback, ui.set_visible, xpcall, pairs  ui_get, ui_set, get_local_player, get_prop, sqrt, bit_band, ui_set_visible = ui.get, ui.set, entity.get_local_player, entity.get_prop, math.sqrt, bit.band, ui.set_visible--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua
client_latency, client_set_clan_tag, client_log, client_draw_rectangle, client_draw_indicator, client_draw_circle_outline, client_timestamp, client_world_to_screen, client_userid_to_entindex = client.latency, client.set_clan_tag, client.log, client.draw_rectangle, client.draw_indicator, client.draw_circle_outline, client.timestamp, client.world_to_screen, client.userid_to_entindex
client_draw_circle, client_draw_gradient, client_set_event_callback, client_screen_size, client_trace_line, client_draw_text, client_color_log = client.draw_circle, client.draw_gradient, client.set_event_callback, client.screen_size, client.trace_line, client.draw_text, client.color_log
client_system_time, client_delay_call, client_visible, client_exec, client_open_panorama_context, client_set_cvar, client_eye_position = client.system_time, client.delay_call, client.visible, client.exec, client.open_panorama_context, client.set_cvar, client.eye_position
client_draw_hitboxes, client_get_cvar, client_draw_line, client_camera_angles, client_draw_debug_text, client_random_int, client_random_float = client.draw_hitboxes, client.get_cvar, client.draw_line, client.camera_angles, client.draw_debug_text, client.random_int, client.random_float
entity_get_local_player, entity_is_enemy, entity_is_dormant, entity_hitbox_position, entity_get_player_name, entity_get_steam64, entity_get_bounding_box, entity_get_all, entity_set_prop = entity.get_local_player, entity.is_enemy, entity.is_dormant, entity.hitbox_position, entity.get_player_name, entity.get_steam64, entity.get_bounding_box, entity.get_all, entity.set_prop
entity_is_alive, entity_get_player_weapon, entity_get_prop, entity_get_players, entity_get_classname = entity.is_alive, entity.get_player_weapon, entity.get_prop, entity.get_players, entity.get_classname
globals_realtime, globals_absoluteframetime, globals_tickcount, globals_curtime, globals_mapname, globals_tickinterval, globals_framecount, globals_frametime, globals_maxplayers = globals.realtime, globals.absoluteframetime, globals.tickcount, globals.curtime, globals.mapname, globals.tickinterval, globals.framecount, globals.frametime, globals.maxplayers
ui_new_slider, ui_new_combobox, ui_reference, ui_set_visible, ui_is_menu_open, ui_new_color_picker, ui_set_callback, ui_set = ui.new_slider, ui.new_combobox, ui.reference, ui.set_visible, ui.is_menu_open, ui.new_color_picker, ui.set_callback, ui.set
ui_new_checkbox, ui_new_hotkey, ui_new_button, ui_new_multiselect, ui_get = ui.new_checkbox, ui.new_hotkey, ui.new_button, ui.new_multiselect, ui.get
math_ceil, math_tan, math_cos, math_sinh, math_pi, math_max, math_atan2, math_floor, math_sqrt, math_deg, math_atan, math_fmod, math_acos = math.ceil, math.tan, math.cos, math.sinh, math.pi, math.max, math.atan2, math.floor, math.sqrt, math.deg, math.atan, math.fmod, math.acos
math_pow, math_abs, math_min, math_sin, math_log, math_exp, math_cosh, math_asin, math_rad = math.pow, math.abs, math.min, math.sin, math.log, math.exp, math.cosh, math.asin, math.rad
table_sort, table_remove, table_concat, table_insert = table.sort, table.remove, table.concat, table.insert
string_find, string_format, string_gsub, string_len, string_gmatch, string_match, string_reverse, string_upper, string_lower, string_sub = string.find, string.format, string.gsub, string.len, string.gmatch, string.match, string.reverse, string.upper, string.lower, string.sub
renderer_line, renderer_indicator, renderer_world_to_screen, renderer_circle_outline, renderer_rectangle, renderer_gradient, renderer_circle, renderer_text = renderer.line, renderer.indicator, renderer.world_to_screen, renderer.circle_outline, renderer.rectangle, renderer.gradient, renderer.circle, renderer.text
--end of local variables ui_indicator_combobox4 client_latency, client_log, client_draw_rectangle, client_draw_circle_outline, client_userid_to_entindex, client_draw_indicator, client_draw_gradient, client_set_event_callback, client_screen_size, client_eye_position = client.latency, client.log, client.draw_rectangle, client.draw_circle_outline, client.userid_to_entindex, client.draw_indicator, client.draw_gradient, client.set_event_callback, client.eye_position client_draw_circle, client_color_log, client_delay_call, client_draw_text, client_visible, client_exec, client_trace_line, client_set_cvar = client.draw_circle, client.color_log, client.delay_call, client.draw_text, client.visible, client.exec, client.trace_line, client.set_cvar client_world_to_screen, client_draw_hitboxes, client_get_cvar, client_draw_line, client_camera_angles, client_draw_debug_text, client_random_int, client_random_float = client.world_to_screen, client.draw_hitboxes, client.get_cvar, client.draw_line, client.camera_angles, client.draw_debug_text, client.random_int, client.random_float entity_get_local_player, entity_is_enemy, entity_hitbox_position, entity_get_player_name, entity_get_steam64, entity_get_bounding_box, entity_get_all, entity_set_prop = entity.get_local_player, entity.is_enemy, entity.hitbox_position, entity.get_player_name, entity.get_steam64, entity.get_bounding_box, entity.get_all, entity.set_prop entity_is_alive, entity_get_player_weapon, entity_get_prop, entity_get_players, entity_get_classname = entity.is_alive, entity.get_player_weapon, entity.get_prop, entity.get_players, entity.get_classname globals_realtime, globals_absoluteframetime, globals_tickcount, globals_curtime, globals_mapname, globals_tickinterval, globals_framecount, globals_frametime, globals_maxplayers = globals.realtime, globals.absoluteframetime, globals.tickcount, globals.curtime, globals.mapname, globals.tickinterval, globals.framecount, globals.frametime, globals.maxplayers ui_new_slider, ui_new_combobox, ui_reference, ui.set_visible, ui_is_menu_open, ui_new_color_picker, ui.set_callback, ui.set, ui_new_checkbox, ui_new_hotkey, ui_new_button, ui_new_multiselect, ui.get = ui.new_slider, ui.new_combobox, ui.reference, ui.set_visible, ui.is_menu_open, ui.new_color_picker, ui.set_callback, ui.set, ui.new_checkbox, ui.new_hotkey, ui.new_button, ui.new_multiselect, ui.get math_ceil, math_tan, math_log10, math_randomseed, math_cos, math_sinh, math_random, math_huge, math_pi, math_max, math_atan2, math_ldexp, math_floor, math_sqrt, math_deg, math_atan, math_fmod = math.ceil, math.tan, math.log10, math.randomseed, math.cos, math.sinh, math.random, math.huge, math.pi, math.max, math.atan2, math.ldexp, math.floor, math.sqrt, math.deg, math.atan, math.fmod math_acos, math_pow, math_abs, math_min, math_sin, math_frexp, math_log, math_tanh, math_exp, math_modf, math_cosh, math_asin, math_rad = math.acos, math.pow, math.abs, math.min, math.sin, math.frexp, math.log, math.tanh, math.exp, math.modf, math.cosh, math.asin, math.rad table_maxn, table_foreach, table_sort, table_remove, table_foreachi, table_move, table_getn, table_concat, table_insert = table.maxn, table.foreach, table.sort, table.remove, table.foreachi, table.move, table.getn, table.concat, table.insert string_find, string_format, string_rep, string_gsub, string_len, string_gmatch, string_dump, string_match, string_reverse, string_byte, string_char, string_upper, string_lower, string_sub = string.find, string.format, string.rep, string.gsub, string.len, string.gmatch, string.dump, string.match, string.reverse, string.byte, string.char, string.upper, string.lower, string.sub bit_band, client_delay_call, client_set_event_callback, entity_get_local_player, entity_get_player_weapon, entity_get_prop, print, func, select, table_insert, table_sort, type, ui.get, ui_name, ui_new_checkbox, ui_new_combobox, ui_new_multiselect, ui_reference, ui.set, ui.set_callback, ui.set_visible, xpcall, pairs = bit.band, client.delay_call, client.set_event_callback, entity.get_local_player, entity.get_player_weapon, entity.get_prop, print, func, select, table.insert, table.sort, type, ui.get, ui.name, ui.new_checkbox, ui.new_combobox, ui.new_multiselect, ui.reference, ui.set, ui.set_callback, ui.set_visible, xpcall, pairs --end of local variables adaptive_weapons = { ["Global"] = {}, ["Auto"] = {11, 38}, ["Awp"] = {9}, ["Scout"] = {40}, ["Heavy pistol"] = {1, 64}, ["Pistol"] = {2, 3, 4, 30, 32, 36, 61, 63}, ["Rifle"] = {7, 8, 10, 13, 16, 39, 60}, --["Submachine gun"] = {17, 19, 24, 26, 33, 34}, --["Machine gun"] = {14, 28}, --["Shotgun"] = {25, 27, 29, 35}, } function collect_keys(tbl, sort) local keys = {} sort = sort or true for k in pairs(tbl) do  client_camera_angles, client_color_log, client_create_interface, client_delay_call, client_draw_hitboxes, client_eye_position, client_find_signature, client_get_cvar, client_latency, client_log, client_screen_size, client_set_cvar, client_set_event_callback, client_update_player_list, client_userid_to_entindex, client_visible, entity_get_classname, entity_get_local_player, entity_get_player_name, entity_get_player_weapon, entity_get_players, entity_get_prop, entity_hitbox_position, globals_absoluteframetime, globals_realtime, globals_tickinterval, math_abs, math_atan2, math_floor, math_pow, math_sqrt, renderer_circle, renderer_circle_outline, renderer_indicator, renderer_text, renderer_world_to_screen, require, string_format, string_match, table_concat, table_insert, table_remove, ui_get, ui_new_button, ui_new_checkbox, ui_new_color_picker, ui_new_combobox, ui_new_hotkey, ui_new_multiselect, ui_new_slider, ui_reference, ui_set, ui_set_callback, ui_set_visible, error, pairs = client.camera_angles, client.color_log, client.create_interface, client.delay_call, client.draw_hitboxes, client.eye_position, client.find_signature, client.get_cvar, client.latency, client.log, client.screen_size, client.set_cvar, client.set_event_callback, client.update_player_list, client.userid_to_entindex, client.visible, entity.get_classname, entity.get_local_player, entity.get_player_name, entity.get_player_weapon, entity.get_players, entity.get_prop, entity.hitbox_position, globals.absoluteframetime, globals.realtime, globals.tickinterval, math.abs, math.atan2, math.floor, math.pow, math.sqrt, renderer.circle, renderer.circle_outline, renderer.indicator, renderer.text, renderer.world_to_screen, require, string.format, string.match, table.concat, table.insert, table.remove, ui.get, ui.new_button, ui.new_checkbox, ui.new_color_picker, ui.new_combobox, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible, error, pairs
-------------
local js = panorama.open()
local persona_api = js.MyPersonaAPI
local name = persona_api.GetName()
local notifications = {}
---[ Vars ]---
client.exec("clear")
client.exec("clear")
client.color_log(200, 200, 255, "-----------------------------")
client.color_log(235, 70, 137, "Welcome " .. name .. "! To Doggosense")
client.color_log(235, 70, 137, "If you have any questions contact me on discord server: XDDDDDDD DOGGOLUA")
client.color_log(200, 200, 255, "-----------------------------")
client.set_event_callback("shutdown", function ()
client.exec("clear")
client.exec("clear")
client.color_log(200, 200, 255, "-----------------------------")
client.color_log(235, 70, 137, "Doggosense bye " .. name .. "!")
client.color_log(200, 200, 255, "-----------------------------")
end)
local notifyTimeout = ui.new_slider("LUA", "B", "Notification timout", 3, 15, 10, true, "s")
local function sendNotification(text, type)
	table.insert(notifications, 1,{text, -1, 0, 2, sYc})
	if type == 1 then
		client.exec("play ui/armsrace_level_up")
	elseif type == 0 then
	else
		client.exec("play player/playerping")
	end
end
local ffi = require('ffi')
ffi.cdef [[
typedef void***(__thiscall* FindHudElement_t)(void*, const char*);
typedef void(__cdecl* ChatPrintf_t)(void*, int, int, const char*, ...);
]]
script = {
	signature_gHud = "\xB9\xCC\xCC\xCC\xCC\x88\x46\x09",
	signature_FindElement = "\x55\x8B\xEC\x53\x8B\x5D\x08\x56\x57\x8B\xF9\x33\xF6\x39\x77\x28",
}
match = client.find_signature("client_panorama.dll", script.signature_gHud) or error("sig1 not found")
hud = ffi.cast("void**", ffi.cast("char*", match) + 1)[0] or error("hud is nil")
helement_match = client.find_signature("client_panorama.dll", script.signature_FindElement) or error("FindHudElement not found")
hudchat = ffi.cast("FindHudElement_t", helement_match)(hud, "CHudChat") or error("CHudChat not found")
chudchat_vtbl = hudchat[0] or error("CHudChat instance vtable is nil")
print_to_chat = ffi.cast("ChatPrintf_t", chudchat_vtbl[27])
function print_chat(text)
	-- \x01 - white
	-- \x02 - red
	-- \x03 - purple
	-- \x04 - green
	-- \x05 - yellow green
	-- \x06 - light green
	-- \x07 - light red
	-- \x08 - gray
	-- \x09 - light yellow
	-- \x0A - gray
	-- \x0C - dark blue
	-- \x10 - gold
	print_to_chat(hudchat, 0, 0, text)
end
inds = {"Anti-aim state", "Autowall", "Body aim", "Triggermagnet", "FOV", "Minimum Damage", "Resolver Override"}
local vars = {
	name_player = nil,
	dynamicfov_new = 0,
	bool_in_fov = false,
	closest_enemy = nil,
	visible = false,
	fire = false,
	penetration_shotme = false,
	cached_target,
	oldcfg = nil,
	legitaa_check = false,
	legitaa_value1 = false,
	legitaa_value2 = false,
	legitaa_show_slider = false,
	legitaa_fps_slider = false,
	legitaa_ping_slider = false,
	legitaa_speed_slider = false,
	legitaa_loss_slider = false,
	legitaa_choke_slider = false,
	legitaa_stop1 = false,
	legitaa_stop2 = false,
	legitaa_stop3 = false,
	legitaa_stop4 = false,
	legitaa_stop5 = false,
	legitaa_updates = 0,
	legitaa_target = 0,
}
local entity = {
	get_local_player = entity.get_local_player,
	is_enemy = entity.is_enemy,
	hitbox_position = entity.hitbox_position,
	get_player_name = entity.get_player_name,
	get_steam64 = entity.get_steam64,
	get_bounding_box = entity.get_bounding_box,
	get_all = entity.get_all,
	set_prop = entity.set_prop,
	is_alive = entity.is_alive,
	get_player_weapon = entity.get_player_weapon,
	get_prop = entity.get_prop,
	get_players = entity.get_players,
	get_classname = entity.get_classname,
	is_dormant = entity.is_dormant,
	get_game_rules = entity.get_game_rules
}
local weapon_classes = {
	['CWeaponG3SG1'] = 'Snipers',
	['CWeaponSCAR20'] = 'Snipers',
	['CWeaponAWP'] = 'Snipers',
	['CWeaponSSG08'] = 'Snipers',
	['CDEagle'] = 'Deagle',
	['CWeaponFiveSeven'] = 'Pistols',
	['CWeaponHKP2000'] = 'Pistols',
	['CWeaponP250'] = 'Pistols',
	['CWeaponGlock'] = 'Pistols',
	['CWeaponElite'] = 'Pistols',
	['CWeaponTec9'] = 'Pistols',
	['CAK47'] = 'Rifles',
	['CWeaponAug'] = 'Rifles',
	['CWeaponFamas'] = 'Rifles',
	['CWeaponGalilAR'] = 'Rifles',
	['CWeaponM4A1'] = 'Rifles',
	['CWeaponSG556'] = 'Rifles',
	['CWeaponMP7'] = 'SMG',
	['CWeaponMP9'] = 'SMG',
	['CWeaponBizon'] = 'SMG',
	['CWeaponP90'] = 'SMG',
	['CWeaponUMP45'] = 'SMG',
	['CWeaponM249'] = 'Machine gun',
	['CWeaponNegev'] = 'Machine gun',
	['CWeaponMag7'] = 'Shotgun',
	['CWeaponNOVA'] = 'Shotgun',
	['CWeaponSawedoff'] = 'Shotgun',
	['CWeaponXM1014'] = 'Shotgun',
}
local function table_contains(tbl, val)
	for i=1, #tbl do
		if tbl[i] == val then
			return true
		end
	end
	return false
end
local function can_see(ent)
	for i = 0, 18 do
		if client_visible(entity_hitbox_position(ent, i)) then
			return true
		end
	end
	return false
end
local function FpsTable()
	local Fps_Table = {}
	Fps_Table[59] = 'Tickrate'
	for i = 1, 241 do
		Fps_Table[59+i] = 59+i .. 'fps'
	end
	return Fps_Table
end
local function setName(delay, name)
	client_delay_call(delay, function()
	client_set_cvar('name', name)
	end)
end
--------------
---[ References ]---
local rage = {
	ragebot = { ui_reference('RAGE', 'Aimbot', 'Enabled') },
	fire = ui_reference('RAGE', 'Other', 'Automatic Fire'),
	penetration = ui_reference('RAGE', 'Other', 'Automatic penetration'),
	fov = ui_reference('RAGE', 'Other', 'Maximum FOV'),
	miss = ui_reference('RAGE', 'Other', 'Log misses due to spread'),
	force_safe_point = ui_reference('RAGE', 'Aimbot', 'Force safe point'),
	force_body_aim = ui_reference('RAGE', 'Aimbot', 'Force body aim'),
	override = ui_reference('RAGE', 'Other', 'Anti-aim correction'),
}
local aa = {
	antiaim = { ui_reference('AA', 'Anti-aimbot angles', 'Enabled') },
	pitch = { ui_reference('AA', 'Anti-aimbot angles', 'Pitch') },
	yaw_base = { ui_reference('AA', 'Anti-aimbot angles', 'Yaw base') },
	yaw = { ui_reference('AA', 'Anti-aimbot angles', 'Yaw') },
	yaw_jitter = { ui_reference('AA', 'Anti-aimbot angles', 'Yaw jitter') },
	body_yaw = { ui_reference('AA', 'Anti-aimbot angles', 'Body yaw') },
	fs_body_yaw = ui_reference('AA', 'Anti-aimbot angles', 'Freestanding body yaw'),
	--	body_yaw_target = { ui_reference('AA', 'Anti-aimbot angles', 'Lower body yaw target') },
	edge_yaw = ui_reference('AA', 'Anti-aimbot angles', 'Edge yaw'),
	fs = { ui_reference('AA', 'Anti-aimbot angles', 'Freestanding') },

}
local fl = {
	fakelag = { ui_reference('AA', 'Fake lag', 'Enabled') },
	limit = ui_reference('AA', 'Fake lag', 'Limit'),
}
local misc = {
	cfg = { ui_reference('CONFIG', 'Presets', 'Presets') },
	damage = ui_reference('MISC', 'Miscellaneous', 'Log damage dealt'),
	namesteal = ui_reference('MISC', 'Miscellaneous', 'Steal player name'),
	missed_due = ui.reference("RAGE", "Other", "Log misses due to spread"),
}
local players = {
	lists = ui_reference('PLAYERS', 'Players', 'Player list'),
	whitelist = ui_reference('PLAYERS', 'Adjustments', 'Add to whitelist'),
	reset_all = ui_reference('PLAYERS', 'Players', 'Reset all'),
}
local useless = {
	pitch = { ui_reference('AA', 'Anti-aimbot angles', 'Pitch') },
	yaw_base = { ui_reference('AA', 'Anti-aimbot angles', 'Yaw base') },
	yaw = { ui_reference('AA', 'Anti-aimbot angles', 'Yaw') },
	yaw_jitter = { ui_reference('AA', 'Anti-aimbot angles', 'Yaw jitter') },
	edge_yaw = ui_reference('AA', 'Anti-aimbot angles', 'Edge yaw'),
	fs = { ui_reference('AA', 'Anti-aimbot angles', 'Freestanding') },
	onshot_aa = { ui_reference('AA', 'Other', 'On shot anti-aim') },
	fake_peek = { ui_reference('AA', 'Other', 'Fake peek') },
	double_tap = { ui_reference('RAGE', 'Aimbot', 'Double tap') },
}
ragebot, ragebotmode = ui.reference("RAGE", "Aimbot", "Enabled")
rage_selection = ui.reference("RAGE", "Aimbot", "Target hitbox")
autowall = ui.reference("RAGE", "Other", "Automatic penetration")
rageautofire = ui.reference("RAGE", "Other", "Automatic fire")
hitchance = ui.reference("RAGE", "Aimbot", "Minimum hit chance")
min_dmg = ui.reference("RAGE", "Aimbot", "Minimum damage")
FOVS5 = ui.reference("RAGE", "Other", "Maximum FOV")
silent = ui.reference("RAGE", "Other", "Silent aim")
missed_due = ui.reference("RAGE", "Other", "Log misses due to spread")
aacorrect = ui.reference("RAGE", "OTHER", "Anti-aim correction")
removerecoil = ui.reference("RAGE", "Other", "Remove recoil")
doubletap_reff = ui.reference("RAGE", "Aimbot", "Double tap")
dp_a = ui.reference("RAGE", "Other", "Duck peek assist")
force_body_aim = ui.reference("RAGE", "Aimbot", "Force body aim")
aaenabler = ui.reference("AA", "Anti-aimbot angles", "Enabled")
pitch = ui.reference("AA", "Anti-aimbot angles", "Pitch")
yaw_base = ui.reference("AA", "Anti-aimbot angles", "Yaw base")
yaw, yaw_num = ui.reference("AA", "Anti-aimbot angles", "Yaw")
yaw_jitter = ui.reference("AA", "Anti-aimbot angles", "Yaw jitter")
body, body_num = ui.reference("AA", "Anti-aimbot angles", "Body yaw")
freestand_body_yaw_hide = ui.reference("AA", "Anti-aimbot angles", "Freestanding body yaw")
--lby, whocars = ui.reference("AA", "Anti-aimbot angles", "Lower body yaw target")
edge_yaw_hide = ui.reference("AA", "Anti-aimbot angles", "Edge yaw")
freestand_hide, bind_freestand_hide = ui.reference("AA", "Anti-aimbot angles", "Freestanding")
fakelag_enable, fakelag_key = ui.reference("AA", "Fake lag", "Enabled")
ref_fakelag_enable = ui.reference("AA", "Fake lag", "Limit")
variance = ui.reference("AA", "Fake lag", "Variance")
amount = ui.reference("AA", "Fake lag", "Amount")
checkbox_reference, hotkey_reference = ui.reference("AA", "Other", "Slow motion")
slowmot_type = ui.reference("AA", "Other", "Slow motion")
onshotaa = ui.reference("AA", "Other", "On shot anti-aim")
legitbot, legitbotmode = ui.reference("LEGIT", "Aimbot", "Enabled")
trans = ui.reference("VISUALS", "Effects", "Transparent props")
pen_rec = ui.reference("VISUALS", "Other ESP", "Penetration reticle")
brightness, adjustment = ui.reference("VISUALS", "Effects", "Brightness adjustment")
thirdpersonk, forcethirdpkey = ui.reference("VISUALS", "Effects", "Force third person (alive)")
thirdpersondead = ui.reference("VISUALS", "Effects", "Force third person (dead)")
nameSteal = ui.reference("Misc", "Miscellaneous", "Steal player name")
default_reference = ui.reference("MISC", "Miscellaneous", "Clan tag spammer")
PingSpikeRef, PingSpikeHotkey, PingSpikeSlider = ui.reference("MISC", "Miscellaneous", "Ping spike")
infiniteduck = ui.reference("MISC", "Movement", "Infinite duck")
dpiscale = ui.reference("MISC", "Settings", "DPI scale")
selectedplayer = ui.reference("PLAYERS", "Players", "Player list")
resetlist = ui.reference("PLAYERS", "Players", "Reset all")
whitelist = ui.reference("PLAYERS", "Adjustments", "Add to whitelist")
applyall = ui.reference("PLAYERS", "Adjustments", "Apply to all")
forcebody = ui.reference("PLAYERS", "Adjustments", "Force body yaw")
body_slider = ui.reference("PLAYERS", "Adjustments", "Force body yaw value")
--------------MADE BY TWIST & AGERA-------------------------------------------
label_start_misc = ui.new_label("LUA", "A", "----------------Doggosense----------------")
label_start_misc = ui.new_label("MISC", "Miscellaneous", "----------------Doggosense----------------")
local main_enabled = ui.new_checkbox("MISC", "MISCELLANEOUS", "[Doggosense] Visible min dmg")
local color = ui.new_color_picker("MISC", "MISCELLANEOUS", "Min dmg color", 255, 255, 255, 255)
local function get_MinDMG()
	local dmgMin = ui.reference("rage", "aimbot", "Minimum damage")
	local dmg = ui.get(dmgMin)
	if dmg == nil then return 0 end
	if dmg > 0 then
		return dmg
	end
	return 0
end

----------------------------------------------------------------------------
client.set_event_callback("paint", function()
local minDmg = get_MinDMG( )

if ui.get(main_enabled) and entity.is_alive(entity.get_local_player()) then
	if(minDmg == 0) then
		return
	end
	local r, g, b, a = ui.get(color)
	local indicator = renderer.indicator(r, g, b, a , "DMG: " .. minDmg .. "")
end
end)
local table_insert = table.insert
local table_remove = table.remove
local globals_realtime = globals.realtime
local globals_tickcount = globals.tickcount
local globals_tickinterval = globals.tickinterval
local globals_frametime = globals.frametime
local globals_absoluteframetime = globals.absoluteframetime
local entity_get_all = entity.get_all
local entity_get_prop = entity.get_prop
local entity_get_local_player = entity.get_local_player
local client_draw_rectangle = client.draw_rectangle
local client_draw_text = client.draw_text
local client_screen_size = client.screen_size
local client_latency = client.latency
local ui_get = ui.get
local ui_set_visible = ui.set_visible
local math_floor = math.floor
local math_sqrt = math.sqrt
local math_min = math.min
local math_abs = math.abs
local string_format = string.format
local client_draw_line = client.draw_line
--- lua script created by: light, sapphyrus
--local pingspike_reference = ui.reference("MISC", "Miscellaneous", "Ping spike")
namecombo = ui.new_combobox("MISC", "Settings", "[Doggosense] Name Spammer", "Shitty Shitty Moew Moew", "Doggosense < ALL")
function AIDS(name)
	client.set_cvar("name", name)
end
ui.new_button("MISC", "Settings", "spam", function()
oldName = client.get_cvar("name")
if ui.get(namecombo) == "Shitty Shitty Moew Moew" then
	client.delay_call(0.3, AIDS, "Shitty ")
	client.delay_call(0.6, AIDS, "Shitty Shitty  ")
	client.delay_call(0.9, AIDS, "Shitty Shitty Moew   ")
	client.delay_call(1.2, AIDS, "Shitty Shitty Moew Moew    ")
	client.delay_call(1.5, AIDS, oldName)

elseif ui.get(namecombo) == "Doggosense < ALL" then
	client.delay_call(0.1, AIDS, "Doggosense < ALL ")
	client.delay_call(0.2, AIDS, "Doggosense < ALL  ")
	client.delay_call(0.3, AIDS, "Doggosense < ALL   ")
	client.delay_call(0.5, AIDS, "Doggosense < ALL    ")
	client.delay_call(1.0, AIDS, oldName)
end
end)
client.register_esp_flag("AA", 235, 70, 137, function (slot0)
if not entity.is_enemy(slot0) then
	return false
end
if plist.get(slot0, "Correction active") == true then
	return true
end
return false
end)
local ui_get = ui.get
local client_log = client.log
local client_draw_text = client.draw_text
local client_screen_size = client.screen_size
local fakelag_ref, fakelag_hotkey_ref = ui.reference("AA", "Fake lag", "Enabled")


tm_cb = ui_new_checkbox("LUA", "A", "[Doggosense] Magnet")
rageautofiremagnet = ui_new_hotkey("LUA", "A", "[Doggosense] Magnet", true)
function on_paint()
	if ui_get(tm_cb, true) then
		local width, height = client_screen_size()
		if ui_get(rageautofiremagnet, true) then
			ui_set(rageautofire, true)
			ui_set(ragebotmode, "Always on")
		else
			ui_set(rageautofire, false)
			ui_set(ragebotmode, "On hotkey")
		end
	end
end
client_set_event_callback("paint", on_paint)
oppositeresolver = ui.new_checkbox("LUA", "A", "[Doggosense] Legit AA resolver")
function slot97()
	if ui.get(overridebutton, true) then
		ui.set(oppositeresolver, false)
	else
		return
	end
	if ui.get(body_slider) == 0 and -60 == true then
		ui.set(forcebody, true)
		ui.set(body_slider, 60)
		ui.set(applyall, true)
	end
	if ui.get(body_slider) == 60 and 0 == true then
		ui.set(forcebody, true)
		ui.set(body_slider, -60)
		ui.set(applyall, true)
	end
	if ui.get(body_slider) == -60 and 60 == true then
		ui.set(forcebody, false)
		ui.set(body_slider, 0)
		ui.set(applyall, true)
	end
end
--[[local flag_color = ui.new_checkbox("RAGE", "OTHER", "ok")
local flag_color = ui.new_color_picker("RAGE", "OTHER", "ok", true)
a, aar, g, b, a = ui.reference("rage", "other", "ok")
client.set_event_callback("paint", function()
print(ui.get(r), ":", ui.get(g), ":", ui.get(b), ":", ui.get(a))
end)]]
local forcebody = ui.reference("players", "adjustments", "force body yaw")
local forcebodyyaw = ui.reference("players", "adjustments", "force body yaw value")
local player_list             = ui.reference("PLAYERS", "adjustments", "Apply to all")
local brute_check             = ui.new_checkbox("LUA", "A", "[Doggosense]Manual Resolver")
local brute_key               = ui.new_hotkey("LUA", "A", "Manual Resolver key")
local brute_key_disable       = ui.new_hotkey("LUA", "A", "Resolver disable key")
local flag_check              = ui.new_checkbox("LUA", "A", "Show Side being resolved on player")
local flag_color              = ui.new_color_picker("LUA", "A", "\n flags")
local indicate_enable         = ui.new_checkbox("LUA", "A", "Resolved side indicator")
local indicate_color          = ui.new_color_picker("LUA", "A", "Indicators")
--override key
local canManual
local cantManual
local function setbodyyaw()
	if ui.get(forcebodyyaw) == -60 and canManual == true or ui.get(forcebodyyaw) == 0 and canManual == true then
		ui.set(forcebody, true)
		ui.set(forcebodyyaw, 60)
		ui.set(player_list, true)
		canManual = false
	end
	if ui.get(forcebodyyaw) == 60 and canManual == true then
		ui.set(forcebody, true)
		ui.set(forcebodyyaw, -60)
		ui.set(player_list, true)
		canManual = false
	end
end
function on_paint()
	if ui.get(brute_key) and ui.get(brute_check) then

		if canManual == true then
			setbodyyaw()
			canManual = false
		end
	else
		canManual = true
	end
end
client.set_event_callback("paint", on_paint)
local function setbodyyaw_zero()
	if ui.get(forcebodyyaw) == -60 and cantManual == true or ui.get(forcebodyyaw) == 60 and cantManual == true then
		ui.set(forcebody, false)
		ui.set(forcebodyyaw, 0)
		ui.set(player_list, true)
		cantManual = false
	end
end
function on_paint()
	if ui.get(brute_key_disable) and ui.get(brute_check) then

		if cantManual == true then
			setbodyyaw_zero()
			cantManual = false
		end
	else
		cantManual = true
	end
end
client.set_event_callback("paint", on_paint)
--bruteforce indicator/resolver indicator
bruteforce_ents = {  }
client.set_event_callback("run_command", function(c)
if not ui.is_menu_open() then
	bruteforce_ents = { }
	for _, v in pairs(entity.get_players(true)) do
		if ui.get(forcebodyyaw) == -60 or ui.get(forcebodyyaw) == 60 then
			table.insert(bruteforce_ents, v)
			entity.set_prop(v, "m_flDetectedByEnemySensorTime")
		else
			entity.set_prop(v, "m_flDetectedByEnemySensorTime", 0)
		end
	end
end
end)
client.set_event_callback("paint", function()
if ui.get(brute_check) and ui.get(flag_check) then
	client.update_player_list()
	local r,g,b,a = ui.get(flag_color)
	for _, v in pairs(bruteforce_ents) do
		local bounding_box = {entity.get_bounding_box(v)}
		if #bounding_box == 5 and bounding_box[5] ~= 0 then

			local center = bounding_box[1]+(bounding_box[3]-bounding_box[1])/2
			if ui.get(forcebodyyaw) == 60 then
				renderer.text(center, bounding_box[2]-18, r,g,b,a*bounding_box[5], "bc", 0, "R: LEFT")
			elseif ui.get(forcebodyyaw) == -60 then
				renderer.text(center, bounding_box[2]-18, r,g,b,a*bounding_box[5], "bc", 0, "R: RIGHT")
			end
		end
	end
end
end)
indicator = renderer.indicator
text = renderer.text
w, h = client.screen_size()
draw = {
	box = renderer.rectangle,
	line = renderer.line,
	text = renderer.text,
	measure_text = renderer.measure_text,
	gradient = renderer.gradient
}
h2o = 5
mouse_position = ui.mouse_position
wns = {
	x = database.read("brute_position") or 250,
	y = database.read("brute_position") or 25,
	w = database.read("brute_position") or 150,
	dragging = false,
	resize = false,
	rx = 0,
}
function intersect(x, y, w, h, debug)
	local cx, cy = mouse_position()
	debug = debug or false
	if debug then
		renderer.rectangle(x, y, w, h, 255, 0, 0, 50)
	end
	return cx >= x and cx <= x + w and cy >= y and cy <= y + h
end
client.set_event_callback("paint", function(ctx, entity_index)
if ui.get(indicate_enable, true) and ui.get(brute_check) then
else return
end
local local_player = entity.get_local_player()
if not local_player or not entity.is_alive(local_player) then
	return
end
local cx, cy = mouse_position()
local left_click = client.key_state(0x01)
if not wns.resize and ui.is_menu_open() then
	if wns.dragging and not left_click then
		wns.dragging = false
	end

	if wns.dragging and left_click then
		wns.x = cx - wns.drag_x
		wns.y = cy - wns.drag_y
	end
	if intersect(wns.x, wns.y, wns.w, 10) and left_click then
		wns.dragging = true
		wns.drag_x = cx - wns.x
		wns.drag_y = cy - wns.y
	end
end
local r,g,b,a = ui.get(indicate_color)
if ui.get(forcebodyyaw) == 60 and ui.get(indicate_enable) then
	renderer.indicator(r,g,b,a, "R: LEFT")
end
if ui.get(forcebodyyaw) == -60 and ui.get(indicate_enable) then
	renderer.indicator(r,g,b,a, "R: RIGHT")
end
if ui.get(forcebody) == false and ui.get(indicate_enable) then
	renderer.indicator(r,g,b,a, "R: OFF")
end
end)

--------------------------------------------------------------------------------
-- Cache common functions
--------------------------------------------------------------------------------
local client_camera_angles, client_trace_line, entity_get_local_player, entity_get_players, entity_get_prop, entity_hitbox_position, math_acos, math_cos, math_sin, math_sqrt, ui_get, ui_new_checkbox, ui_new_hotkey, ui_reference, ui_set, ui_set_callback = client.camera_angles, client.trace_line, entity.get_local_player, entity.get_players, entity.get_prop, entity.hitbox_position, math.acos, math.cos, math.sin, math.sqrt, ui.get, ui.new_checkbox, ui.new_hotkey, ui.reference, ui.set, ui.set_callback
--------------------------------------------------------------------------------
-- Constants and variables
--------------------------------------------------------------------------------
local enable_ref
local threshold_ref
local fov_ref
local penetration_ref
local PI = 3.14159265358979323846
local DEG_TO_RAD = PI / 180.0
local RAD_TO_DEG = 180.0 / PI
--------------------------------------------------------------------------------
-- Utility functions
--------------------------------------------------------------------------------
local function vec3_normalize(x, y, z)
	local len = math_sqrt(x*x + y*y + z*z)
	if len == 0 then
		return 0, 0, 0
	end
	local r = 1 / len
	return x*r, y*r, z*r
end
local function vec3_dot(ax, ay, az, bx, by, bz)
	return ax*bx + ay*by + az*bz
end
local function angle_to_vec(pitch, yaw)
	local pitch_rad, yaw_rad = DEG_TO_RAD*pitch, DEG_TO_RAD*yaw
	local sp, cp, sy, cy = math_sin(pitch_rad), math_cos(pitch_rad), math_sin(yaw_rad), math_cos(yaw_rad)
	return cp*cy, cp*sy, -sp
end
local function calculate_fov_to_player(ent, lx, ly, lz, fx, fy, fz)
	local px, py, pz = entity_get_prop(ent, "m_vecOrigin")
	local dx, dy, dz = vec3_normalize(px-lx, py-ly, pz-lz)
	local dot_product = vec3_dot(dx, dy, dz, fx, fy, fz)
	local cos_inverse = math_acos(dot_product)
	return RAD_TO_DEG*cos_inverse
end
local function get_closest_player_to_crosshair(lx, ly, lz, pitch, yaw)
	local fx, fy, fz = angle_to_vec(pitch, yaw)
	local enemy_players = entity_get_players(true)
	local nearest_player
	local nearest_player_fov = math.huge
	for i=1, #enemy_players do
		local enemy_ent = enemy_players[i]
		-- Calculate the FOV to the player so we can determine if they are closer than the stored player
		local fov_to_player = calculate_fov_to_player(enemy_ent, lx, ly, lz, fx, fy, fz)
		if fov_to_player <= nearest_player_fov then
			nearest_player = enemy_ent
			nearest_player_fov = fov_to_player
		end
	end
	return nearest_player, nearest_player_fov
end
local function is_player_visible(local_player, lx, ly, lz, ent)
	local visible_hitboxes = 0
	local visible_hitbox_threshold = ui.get(threshold_ref)
	for i=0, 18 do
		-- Get the current hitbox position so that we can run a trace to it and see if it is hit
		local ex, ey, ez = entity_hitbox_position(ent, i)
		-- Run the trace from our eye position to the hitbox if the trace hits the enemy then we know the player is visible
		local _, entindex = client_trace_line(local_player, lx, ly, lz, ex, ey, ez)
		if entindex == ent then
			-- Increment the visible hitbox counter so that we can determine if the player meets the threshold
			visible_hitboxes = visible_hitboxes + 1
		end
	end
end
--------------------------------------------------------------------------------
-- Callback functions
--------------------------------------------------------------------------------
local function on_setup_command()
	-- Get the aimbots maximum fov so we can determine if a player is within that range
	local maximum_fov = ui_get(fov_ref)
	local local_player = entity_get_local_player()
	-- Get the local players origin, pitch, and yaw so that we can calculate our FOV to enemies
	local pitch, yaw = client_camera_angles()
	local lx, ly, lz = entity_get_prop(local_player, "m_vecOrigin")

	-- Get the nearest player to our crosshair, and the fov to that player so we can determine if they are in the aimbots range
	local nearest_player, nearest_player_fov = get_closest_player_to_crosshair(lx, ly, lz, pitch, yaw)
	-- Get our view offset and add it to our origin so that we can trace from our eye position
	local view_offset = entity_get_prop(local_player, "m_vecViewOffset[2]")
	local lz = lz + view_offset
	if nearest_player ~= nil and nearest_player_fov <= maximum_fov then
		local penetration_state = is_player_visible(local_player, lx, ly, lz, nearest_player)
	end
end
local function on_legit_pen_toggle(ref)
	local script_state = ui_get(ref)

	ui.set_visible(threshold_ref, script_state)
	-- If the script is not enabled there is no point in invoking the event callback so we'll dynamically set / unset it based on the script state
	local update_callback = script_state and client.set_event_callback or client.unset_event_callback
	update_callback("setup_command", on_setup_command)
end
--------------------------------------------------------------------------------
-- Initilization code
--------------------------------------------------------------------------------
local function init()
	enable_ref      = ui_new_checkbox("LUA", "A", "[Doggosense] Legit AWall")
	threshold_ref   = ui.new_slider("LUA", "A", "\nVisible hitbox threshold", 0, 18, 4, true)
	fov_ref         = ui_reference("RAGE", "Other", "Maximum FOV")
	penetration_ref = ui_reference("RAGE", "Other", "Automatic penetration")
	on_legit_pen_toggle(enable_ref)
	ui_set_callback(enable_ref, on_legit_pen_toggle)
end
init()
local client_set_event_callback = client.set_event_callback
local ui_get, ui_set, ui_new_hotkey = ui.get, ui.set, ui.new_hotkey
local client_draw_indicator = client.draw_indicator
local autowall = ui.reference("RAGE", "Other", "Automatic Penetration")
local autowalltoggle = ui_new_hotkey("LUA", "A", "Toggle Autowall")
local function on_paint(ctx)
	if ui_get(autowalltoggle) then
		if not ui_get(autowall) then
			ui_set(autowall, true)
		end
		local w, h = client.screen_size()
		local center = { w/2, h/2 }
		local y11 = (-1 >= 0) and (center[2] - -1) or (center[2] - -15)
		renderer.text(center[1], y11, 235, 70, 137, 255, "-cb", 0, "AUTOWALL")
	else
		if ui_get(autowall) then
			ui_set(autowall, false)
		end
	end
end
client_set_event_callback("paint", on_paint)
--------------------------------------------------------------------------------
-- Caching common functions
--------------------------------------------------------------------------------
local client_camera_angles, entity_get_local_player, entity_get_players, entity_get_prop, math_acos, math_cos, math_floor, math_sin, math_sqrt, renderer_indicator, ui_get, ui_new_checkbox, ui_new_color_picker, ui_new_slider, ui_reference, ui_set, ui_set_callback, ui_set_visible = client.camera_angles, entity.get_local_player, entity.get_players, entity.get_prop, math.acos, math.cos, math.floor, math.sin, math.sqrt, renderer.indicator, ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
--------------------------------------------------------------------------------
-- Constants and variables
--------------------------------------------------------------------------------
local enable_ref
local color_ref
local fov_min_ref
local fov_max_ref
local distance_ref
local maximum_fov_ref
local PI = 3.14159265358979323846
local DEG2RAD = PI/180.0
local RAD2DEG = 180.0/PI
local BASE_DISTANCE = 1000.0
local scaled_fov
--------------------------------------------------------------------------------
-- Utility functions
--------------------------------------------------------------------------------
local function get_distance(x1, y1, z1, x2, y2, z2)
	return math_sqrt((x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2)
end
local function clamp(val, min, max)
	if val < min then
		val = min
	end
	if val > max then
		val = max
	end
	return val
end
local function lerp(min, max, factor)
	factor = clamp(factor, 0.0, 1.0)
	local lerp_result = (1-factor)*min+factor*max
	return clamp(lerp_result, min, max)
end
local function vec3_normalize(x, y, z)
	local len = math_sqrt(x*x + y*y + z*z)
	if len == 0 then
		return 0, 0, 0
	end
	local r = 1/len
	return x*r, y*r, z*r
end
local function vec3_dot(ax, ay, az, bx, by, bz)
	return ax*bx + ay*by + az*bz
end
local function angle_to_vec(pitch, yaw)
	pitch, yaw = DEG2RAD*pitch, DEG2RAD*yaw
	local cos_pitch, cos_yaw = math_cos(pitch), math_cos(yaw)
	local sin_pitch, sin_yaw = math_sin(pitch), math_sin(yaw)
	return cos_pitch*cos_yaw, cos_pitch*sin_yaw, -sin_pitch
end
local function calculate_fov_to_player(ent, lx, ly, lz, fx, fy, fz)
	local px, py, pz = entity_get_prop(ent, "m_vecOrigin")
	local dx, dy, dz = vec3_normalize(px-lx, py-ly, pz-lz)
	local dot_product = vec3_dot(dx, dy, dz, fx, fy, fz)
	local cos_inverse = math_acos(dot_product)
	return RAD2DEG*cos_inverse
end
local function get_closest_player(lx, ly, lz, pitch, yaw)
	local fx, fy, fz = angle_to_vec(pitch, yaw)
	local enemy_players = entity_get_players(true)
	local nearest_player
	local nearest_player_fov = math.huge
	for i=1, #enemy_players do
		local player = enemy_players[i]
		local fov_to_player = calculate_fov_to_player(player, lx, ly, lz, fx, fy, fz)
		if fov_to_player <= nearest_player_fov then
			nearest_player = player
			nearest_player_fov = fov_to_player
		end
	end
	return nearest_player, nearest_player_fov
end
--------------------------------------------------------------------------------
-- Callback functions
--------------------------------------------------------------------------------
local function on_setup_command()
	local pitch, yaw = client_camera_angles()
	local local_player = entity_get_local_player()
	local lx, ly, lz = entity_get_prop(local_player, "m_vecOrigin")
	local min_fov = ui_get(fov_min_ref)
	local max_fov = ui_get(fov_max_ref)
	local max_distance = BASE_DISTANCE*ui_get(distance_ref)*0.01
	local nearest_player = get_closest_player(lx, ly, lz, pitch, yaw)
	if nearest_player ~= nil then
		local ex, ey, ez = entity_get_prop(nearest_player, "m_vecOrigin")
		local distance = get_distance(lx, ly, lz, ex, ey, ez)
		scaled_fov = lerp(min_fov, max_fov, (max_distance-distance)/max_distance)
		scaled_fov = math_floor(scaled_fov)
	else
		scaled_fov = min_fov
	end
	ui_set(maximum_fov_ref, scaled_fov)
end
local function on_dynamic_fov_toggle(ref)
	local state = ui_get(ref)
	ui_set_visible(fov_min_ref, state)
	ui_set_visible(fov_max_ref, state)
	ui_set_visible(distance_ref, state)
	local update_callback = state and client.set_event_callback or client.unset_event_callback
	update_callback("paint", on_paint)
	update_callback("setup_command", on_setup_command)
end
--------------------------------------------------------------------------------
-- Initilization code
--------------------------------------------------------------------------------
local function init()
	enable_ref = ui_new_checkbox("LUA", "A", "[Doggosense] Dynamic FOV")
	color_ref = ui_new_color_picker("LUA", "A", "\nIndicator color", 255, 255, 255, 255)
	fov_min_ref = ui_new_slider("LUA", "A", "\nMinimum FOV", 1, 180, 3, true, '°')
	fov_max_ref = ui_new_slider("LUA", "A", "\nMaximum FOV", 1, 180, 35, true, '°')
	distance_ref = ui_new_slider("LUA", "A", "Distance scale", 0, 350, 1000, true, "x", 0.01)
	maximum_fov_ref = ui_reference("RAGE", "Other", "Maximum FOV")
	on_dynamic_fov_toggle(enable_ref)
	ui_set_callback(enable_ref, on_dynamic_fov_toggle)
end
init()
local function on_paint()
	local r, g, b, a = ui_get(color_ref)
	renderer_indicator(r, g, b, a, "FOV: ", scaled_fov, '°')
end
client_set_event_callback("paint", on_paint)
label_end_misc = ui.new_label("LUA", "A", "----------------Doggosense----------------")
local sentences = {
	"nice 500 iq?",
	"Cya panorama joiner",
	"1 fucking nigger",
	"Later newfag 500 iq? ",
	"Damn you look good in my F12 folder",
	"Doggosense owns you fucking doggie :D:D:D:",
	"How bout you refund that shit paste u got there? =DDD",
	"Fucking Walkbot",
	"How about you stop deranking? smh",
	"Never had a chance :v",
	"Most of the ppl miss me, you dont even shoot nn :DDD",
	"NOOB (◣_◢)",
	"Shitty Shitty, Meow Moew",
	"take the cooldown and let your team surr retard",
	"uid police here present your user identification number right now",
	"better buy new paste nn",
	"drink some alcohol",
	"too ez for Doggosense",
	"ez for my iq 500.",
	"nice antiaim, you sell?",
	"refund your pastebowhook right now pasteuser dog",
	"thats going in my media compilation right there get shamed retard rofl",
	"Maybe next time :shrug:"
}
local ui = {
	new_checkbox = ui.new_checkbox,
	get = ui.get
}
local client = {
	set_event_callback = client.set_event_callback,
	userid_to_entindex = client.userid_to_entindex,
	exec = client.exec,
	log = client.log
}
local entity = {
	get_local_player = entity.get_local_player,
	get_player_name = entity.get_player_name
}
local killsay_enabled = ui.new_checkbox("MISC", "Miscellaneous", "[Doggosense] Killsay")
local function on_player_death(event)
	if not ui.get(killsay_enabled) then return end
	local local_player = entity.get_local_player()
	local attacker = client.userid_to_entindex(event.attacker)
	local victim = client.userid_to_entindex(event.userid)
	if local_player == nil or attacker == nil or victim == nil then
		return
	end
	if attacker == local_player and victim ~= local_player then
		local killsay = "say " .. sentences[math.random(#sentences)]
		killsay = string.gsub(killsay, "$name", entity.get_player_name(victim))
		client.log(killsay)
		client.exec(killsay)
	end
end
math.randomseed(133742069)
math.random(); math.random(); math.random()
client.set_event_callback("player_death", on_player_death)
--ctag
local leetifyTable = {A = "4", B = "6", C = "<", D = "d", E = "3", F = "f", G = "&", H = "#", I = "!", J = "j", K = "k", L = "1", M = "m", N = "|\\|", O = "0", P = "p", Q = "q", R = "r", S = "5", T = "7", U = "u", V = "\\/", W = "w", X = "x", Y = "y", Z = "z"}
local enableClantag = ui.new_checkbox("MISC", "Miscellaneous", "[Doggosense] Clantag Spammer")
local mainTag = "Doggosense.beta"
local previousTag = ""
local chokedPackets = 0
ui_set_callback(enableClantag, function()
local enabled = ui.get(enableClantag)

end)
client.set_event_callback("net_update_end", function()
if not (ui.get(enableClantag)) then return end
if (chokedPackets ~= 0) then
	return
end

local curTime = globals.curtime()
local tagSpeed = 5
local tag = "Doggosense.beta"
local tagLength = string.len(tag)

if (tagLength == 0) then return end

tagLength = 0
for i=1, #tag do
	local tmpChar = string.sub(tag, i, i)
	local leetChar = leetifyTable[string.upper(tmpChar)]

	if (leetChar ~= nil and leetChar ~= tmpChar) then
		tagLength = tagLength + string.len(leetChar) + 1
	else
		tagLength = tagLength + 1
	end
end
tagLength = tagLength * 2

local tagIndex = math.floor(curTime * tagSpeed % tagLength + 1)
local setTag = ""
local modLeft = -1

local realI = 0
local fakeI = 1

local backwards = false

local power = tagIndex
local setTag = ""
local realI = 0

for i=1, tagLength/2 do
	local iChar = string.sub(tag, i, i)
	local leetChar = leetifyTable[string.upper(iChar)]

	if (leetChar == nil or string.lower(iChar) == leetChar) then --Doesnt have a leetify
		if (power > 0) then
			setTag = setTag .. iChar
			power = power - 1
		end
	else
		local tmpChars = ""
		for j=1, #leetChar do
			if (power > 0) then
				tmpChars = tmpChars .. string.sub(leetChar, j, j)
				power = power - 1
			end
		end

		if (power > 0) then
			setTag = setTag .. iChar
			power = power - 1
		else
			setTag = setTag .. tmpChars
		end
	end
end

if (tagIndex > tagLength/2) then
	setTag = ""
	power = tagLength - tagIndex

	for i=1, tagLength/2 do
		local iChar = string.sub(tag, i, i)
		local leetChar = leetifyTable[string.upper(iChar)]

		if (leetChar == nil or string.lower(iChar) == leetChar) then --Doesnt have a leetify
			if (power > 0) then
				setTag = setTag .. iChar
				power = power - 1
			end
		else
			local tmpChars = ""
			for j=1, #leetChar do
				if (power > 0) then
					tmpChars = tmpChars .. string.sub(leetChar, j, j)
					power = power - 1
				end
			end

			if (power > 0) then
				setTag = setTag .. iChar
				power = power - 1
			else
				setTag = setTag .. tmpChars
			end
		end
	end
end
if (previousTag ~= setTag) then
	client_set_clan_tag(setTag)
	previousTag = setTag
end
end)
client.set_event_callback("run_command", function(cmd)
chokedPackets = cmd.chokedcommands

return
end)
--ctag
ui_set_visible(default_reference, true)
whitelist = ui.new_checkbox("Misc", "Miscellaneous", "[Doggosense] Anti-Reportbot")
client.set_event_callback("cs_win_panel_match", function ()
if not ui_get(whitelist) then
	return
end
client_log("match ended")
client_delay_call(0, function()
client_exec("disconnect")
end)
end)
miss_log = ui.new_checkbox("MISC", "Miscellaneous", "[Doggosense] Log misses in Chat")
function on_aim_miss(e)
	if ui.get(miss_log) then
		ui_set(missed_due, false)
		local hitgroup_names = { "body", "head", "chest", "stomach", "left arm", "right arm", "left leg", "right leg", "neck", "?", "gear" }
		local group = hitgroup_names[e.hitgroup + 1] or "?"
		local target_name = entity_get_player_name(e.target)
		local reason
		local entityHealth = entity_get_prop(e.target, "m_iHealth")
		if (entityHealth == nil) or (entityHealth <= 0) then
			print_chat(" \x01 [\x03Doggosense\x01] \x05The person was killed before your shot was able to hit")
			return
		end
		if e.reason == "?" then
			reason = "Resolver"
		else
			reason = e.reason
		end
		print_chat(" \x01[\x03Doggosense\x01] \x02missed " .. string.lower(target_name) .. "'s " .. " " .. group .. "\x09 due to " .. reason)
	end
end
client.set_event_callback('aim_miss', on_aim_miss)

--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua
Latency = client.latency
LocalPlayer,
GetProp = entity.get_local_player, entity.get_prop
min, abs, sqrt,
floor = math.min, math.abs, math.sqrt, math.floor
RealTime = globals.realtime
TimeStart = RealTime
aaenablers = ui_reference("AA", "Anti-aimbot angles", "Enabled")
pitch = ui_reference("AA", "Anti-aimbot angles", "Pitch")
yaw_base = ui_reference("AA", "Anti-aimbot angles", "Yaw base")
yaw_check, yaw_num = ui_reference("AA", "Anti-aimbot angles", "Yaw")
yaw_jitter = ui_reference("AA", "Anti-aimbot angles", "Yaw jitter")
body, body_num = ui_reference("AA", "Anti-aimbot angles", "Body yaw")
--lby = ui_reference("AA", "Anti-aimbot angles", "Lower body yaw target")
ref_fakeduck = ui_reference("Rage", "Other", "Duck peek assist")
autodirection, autodirection_key = ui_reference("AA", "Anti-aimbot angles", "Freestanding")
edgeyaw = ui_reference("AA", "Anti-aimbot angles", "Edge yaw")
bodyyaw_freestand = ui_reference("AA", "Anti-aimbot angles", "Freestanding body yaw")
legitAA = ui_new_checkbox("AA", "Anti-aimbot angles", "[Doggosense] Legit anti-aim")
legitAAbase = ui_new_combobox("AA", "Anti-aimbot angles", "\n aa_legit_base", "Manual", "Dynamic")
LegitAAHotkey = ui_new_hotkey("AA", "Anti-aimbot angles", "Anti-aim switch key", true)
flip_key = ui_new_hotkey("AA", "Anti-aimbot angles", "Flip Key", true)
legitaa_freestand_type = ui_new_combobox("AA", "Anti-aimbot angles", "Freestanding type", "Edge", "Damage", "Flip + Manual", "Peek real first")
LegitAABreaker = ui_new_combobox("AA", "Anti-aimbot angles", "Legit aa", "Off", "Smart", "Maximum", "Jitter")
ui_indicator_combobox4 = ui_new_combobox("AA", "Anti-aimbot angles", "Anti-aim indicator", "Off", "Metro", "Big Arrows", "Dashes")
ui_indicator_color_picker4 = ui_new_color_picker("AA", "Anti-aimbot angles", "Indicator colour", "0", "115", "255", "255")
local render_text = renderer.text
local GetBoundingBox = entity.get_bounding_box
local world_to_screen = function(x, y, z, func)
local x, y = renderer.world_to_screen(x, y, z)
if x ~= nil and y ~= nil then
	func(x, y)
end
end
--end of local variables
local leftdamage = 0
local rightdamage = 0
local rad2deg = function(rad)
return (rad * 180 / math.pi)
end
local deg2rad = function(deg)
return (deg * math.pi / 180)
end
local trace_line = function(entity, start, _end)
return client_trace_line(entity, start.x, start.y, start.z, _end.x, _end.y, _end.z)
end
screenx, screeny = client_screen_size()
local vector = function(x, y, z)
x = x ~= nil and x or 0
y = y ~= nil and y or 0
z = z ~= nil and z or 0
return {
["x"] = x,
["y"] = y,
["z"] = z
}
end
vector_add = function(vector1, vector2)
return {
["x"] = vector1.x + vector2.x,
["y"] = vector1.y + vector2.y,
["z"] = vector1.z + vector2.z
}
end
vector_substract = function(vector1, vector2)
return {
["x"] = vector1.x - vector2.x,
["y"] = vector1.y - vector2.y,
["z"] = vector1.z - vector2.z
}
end
function slot136(slot0, slot1)
for slot5 = 1, #slot0, 1 do
if slot0[slot5] == slot1 then
return true
end
end
return false
end
function slot137(slot0, slot1)
for slot5, slot6 in ipairs(slot0) do
if slot6 == slot1 then
return true, slot5
end
end
return false
end
function slot138()
if ui.get(otherref.tp_alive) and ui.get(otherref_tp_alive_key) then
ui_set_visible(otherref_tp_dead, true)
else
ui_set_visible(otherref_tp_dead, false)
end
end
clamp_angles = function(angle)
angle = angle % 360
angle = (angle + 360) % 360
if angle > 180 then
angle = angle - 360
end
return angle
end
function LAASetup()
if ui.get(legitAA) then
if ui.get(legitAAbase) == "Manual" then
ui_set_visible(LegitAAHotkey, true)
elseif ui.get(legitAAbase) == "Dynamic" then
ui_set_visible(LegitAAHotkey, false)
end
else
ui_set_visible(LegitAAHotkey, false)
end
end
function LAAFunc()
----------------------------------------------------------------------LEGITAA
local legita = ui.get(legitAA)
local base = ui.get(legitAAbase)
local aamodes = ui.get(LegitAABreaker)
local edge_freestand_type = ui.get(legitaa_freestand_type)
ui_set_visible(legitAAbase, legita)
ui_set_visible(LegitAABreaker, legita)
ui_set_visible(legitaa_freestand_type, legita and base == "Dynamic")
ui_set_visible(ui_indicator_combobox4, legita)
ui_set_visible(ui_indicator_color_picker4, legita)

----------------------------------------------------------------------LEGITAA more stuff

ui_set_visible(LegitAAHotkey, legita and base == "Manual")
ui_set_visible(flip_key, edge_freestand_type == "Flip + Manual" and legita and base == "Dynamic")
if not ui.get(legitAA) then
ui_set(yaw_check, "Off")
ui_set(body, "Off")
ui_set(autodirection)
ui_set(autodirection_key, "On hotkey")
ui_set(aaenablers, false)
elseif ui.get(legitAA) then
ui_set(yaw_check, "180")
ui_set(yaw_num, 180)
ui_set(body, "Static")
ui_set(autodirection)
ui_set(autodirection_key, "On hotkey")
ui_set(aaenablers, true)
end
end
LAAFunc()
ui_set_callback(legitAA, LAAFunc)
ui_set_callback(legitAAbase, LAAFunc)
ui_set_callback(LegitAAHotkey, LAAFunc)
ui_set_callback(LegitAABreaker, LAAFunc)
ui_set_callback(legitaa_freestand_type, LAAFunc)
get_atan = function(ent, eye_pos, camera)
local data = { id = nil, dst = 2147483647, fov = 360 }
local screenx, screeny = client_screen_size()
local crosshair = screenx / 2, screeny / 2
for i = 0, 19 do
local hitbox = vector(entity_hitbox_position(ent, i))
local ext = vector_substract(hitbox, eye_pos)
local yaw = rad2deg(math.atan2(ext.y, ext.x))
local pitch = -rad2deg(math.atan2(ext.z, math.sqrt(ext.x ^ 2 + ext.y ^ 2)))
local yaw_dif = math.abs(camera.y % 360 - yaw % 360) % 360
local pitch_dif = math.abs(camera.x - pitch) % 360
if yaw_dif > 180 then
yaw_dif = 360 - yaw_dif
end
local dst = math.sqrt(yaw_dif ^ 2 + pitch_dif ^ 2)
local dstcorrect = math.sqrt(ext.x ^ 2 + ext.y ^ 2 + ext.z ^ 2)
if dstcorrect < data.dst then
data.dst = dstcorrect
data.id = i
data.fov = yaw - crosshair
end
end
return data.id, data.dst, data.fov
end
function getdistance()
local get_players = entity_get_players(true)
if #get_players == 0 then
return
end
local eye_pos = vector(client_eye_position())
local camera = vector(client_camera_angles())
camera.z = z_pos ~= nil and 64 or camera.z
local distance = math.huge
local closest_enemy = nil
local adv_fov = 1000
local screenx, screeny = client_screen_size()
local crosshair = screenx / 2, screeny / 2
for i = 1, #get_players do
local hitbox_id, dist, fov = get_atan(get_players[i], eye_pos, camera)
if distance > dist then
distance = dist
local hitbox = hitbox_id
closest_enemy = get_players[i]
adv_fov = fov
end
end
return closest_enemy, hitbox, distance, adv_fov
end
function slot159()
ui_set(pitch, "Off")
ui_set(yaw_base, "Local view")
ui_set(yaw_check, "180")
ui_set(yaw_jitter, "Off")
ui_set(edgeyaw, false)
ui_set(bodyyaw_freestand, false)
ui_set(autodirection_key, "On hotkey")
end
function slot160()
if not ui.get(legitAA) or ui.get(ref_fakeduck) or ui.get(legitAAbase) == "Dynamic" or entity_get_local_player() == nil or entity_get_prop(entity_get_local_player(), "m_lifeState") ~= 0 then
return
end
if entity_get_prop(entity_get_game_rules(), "m_bFreezePeriod") == 1 then
return
end
local screenx, screeny = client_screen_size()
local halfx = screenx / 2
local halfy = screeny / 2
if ui.get(legitAA) then
if ui.get(legitAAbase) == "Manual" then
ui_set(LegitAAHotkey, "Toggle")
if ui.get(LegitAAHotkey) then
slot159()
ui_set(yaw_num, 180)
ui_set(body_num, 55)

else
slot159()
ui_set(yaw_num, 180)
ui_set(body_num, -55)

end
else
end
end
end
edge_count = { [1] = 7, [2] = 12, [3] = 15, [4] = 19, [5] = 23, [6] = 28, [7] = 35, [8] = 39 }
function do_legit_aa()
local local_player = entity_get_local_player()
if not local_player or not entity_is_alive(local_player) then
return
end
local m_vecOrigin = vector(entity_get_prop(local_player, "m_vecOrigin"))
local m_vecViewOffset = vector(entity_get_prop(local_player, "m_vecViewOffset"))
local m_vecOrigin = vector_add(m_vecOrigin, m_vecViewOffset)
local radius = 20 + 110 + 0.1
local step = math.pi * 2.0 / edge_count[8]
local camera = vector(client_camera_angles())
local central = deg2rad(math.floor(camera.y + 0.5))
local data = {
fraction = 1,
surpassed = false,
angle = vector(0, 0, 0),
var = 0,
side = "LAST KNOWN"
}
for a = central, math.pi * 3.0, step do
if a == central then
central = clamp_angles(rad2deg(a))
local trace_line = function(entity, start, _end)
return client_trace_line(entity, start.x, start.y, start.z, _end.x, _end.y, _end.z)
end
end
local clm = clamp_angles(central - rad2deg(a))
local abs = math.abs(clm)
if abs < 90 and abs > 1 then
local side = "LAST KNOWN"
local location = vector(
radius * math.cos(a) + m_vecOrigin.x,
radius * math.sin(a) + m_vecOrigin.y,
m_vecOrigin.z
)
local _fr, entindex = client_trace_line(local_player, m_vecOrigin.x, m_vecOrigin.y, m_vecOrigin.z, location.x, location.y, location.z)
if math.floor(clm + 0.5) < -21 then
side = "RIGHT"
end
if math.floor(clm + 0.5) > 21 then
side = "LEFT"
end
local fr_info = {
fraction = _fr,
surpassed = (_fr < 1),
angle = vector(0, clamp_angles(rad2deg(a)), 0),
var = math.floor(clm + 0.5),
side = side--[ 0 - center / 1 - right / 2 - left ]
}
if data.fraction > _fr then
data = fr_info
end
end
end
return data
end
function dodynamic()
local local_player = entity_get_local_player()
if not local_player or not entity_is_alive(local_player) then
return
end
local local_player = entity_get_local_player()
local origin = vector(entity_get_prop(local_player, "m_vecOrigin"))
local collision = (entity_get_prop(local_player, "m_Collision"))
local vecmin = vector(entity_get_prop(local_player, "m_vecMins"))
local vecmax = vector(entity_get_prop(local_player, "m_vecMaxs"))
local min = vector_add(vecmin, origin)
local max = vector_add(vecmax, origin)
if not ui.get(legitAA) or ui.get(ref_fakeduck) or ui.get(legitAAbase) == "Manual" then
return
end
if ui.get(legitAA) and ui.get(legitAAbase) == "Dynamic" then
if entity_get_prop(entity_get_game_rules(), "m_bFreezePeriod") == 1 then
return
end
local data = do_legit_aa()
if data == nil then
return
end
if data.fraction < 1 and ui.get(legitaa_freestand_type) == "Edge" then
slot159()
ui_set(body_num, data.var > 0 and 55 or -55)
ui_set(yaw_num, 180)
elseif data.fraction < 1 and ui.get(legitaa_freestand_type) == "Peek real first" then
slot159()
ui_set(body_num, data.var > 0 and -55 or 55)
ui_set(yaw_num, 180)
end
end
if ui.get(legitaa_freestand_type) == "Damage" then
else
return
end
closest_to_crosshair = getdistance()
if closest_to_crosshair ~= nil then
local hitbox = vector(entity_hitbox_position(local_player, 0))
local viewtest = vector(client_eye_position())
local yawadd = ui.get(yaw_num)
local desync = ui.get(1)
local enemyx, enemyy, enemyz = entity_get_prop(closest_to_crosshair, "m_vecOrigin")
local enemyvx, enemyvy, enemyvz = entity_get_prop(closest_to_crosshair, "m_vecViewOffset")
local enemyhitbox = vector(entity_hitbox_position(closest_to_crosshair, 0))
rightdamage = 0
leftdamage = 0
local rightchecky = math_sin(hitbox.x) * 55 + math_cos(hitbox.y) * 55
local leftchecky = math_sin(hitbox.x) * -55 + math_cos(hitbox.y) * -55
local rightcheck
local leftcheck = hitbox.y - 10
if hitbox.y ~= nil then
local leftent, leftdmg = client_trace_bullet(local_player, hitbox.x, leftcheck, hitbox.z, enemyhitbox.x, enemyhitbox.y, enemyhitbox.z)
local rightent, rightdmg = client_trace_bullet(local_player, hitbox.x, rightchecky, hitbox.z, enemyhitbox.x, enemyhitbox.y, enemyhitbox.z)
if leftent ~= nil then
leftdamage = client_scale_damage(leftent, 0, leftdmg)
elseif rightent ~= nil then
rightdamage = client_scale_damage(rightent, 0, rightdmg)
else
end
local screenx, screeny = client_screen_size()
end
else
end
if rightdamage > leftdamage and ui.get(legitaa_freestand_type) == "Damage" then
slot159()
ui_set(yaw_num, 180)
ui_set(body_num, -55)
slot94 = "RIGHT"
else
if ui.get(legitaa_freestand_type) == "Damage" then
slot159()
ui_set(yaw_num, 180)
ui_set(body_num, 55)
slot94 = "LEFT"
end
end
end
anti_resolve_timer = 0
function anti_resolver3()
if ui.get(legitAA, true) then
else
return
end
if ui.get(LegitAABreaker) == "Jitter" then
--ui_set(lby, "Opposite")
if globals.realtime() >= anti_resolve_timer then
client_delay_call(0.08, ui_set, limit, 60)
client_delay_call(0.16, ui_set, limit, 2)
anti_resolve_timer = globals.realtime() + 0.1
end
end
end
client.set_event_callback("run_command", anti_resolver3)
function fyls()
if ui.get(legitAA) == false then
return
else
if ui.get(LegitAABreaker) == "Off" then
ui_set(limit, 60)
ui_set(body, "Static")
elseif ui_get(LegitAABreaker) == "Smart" then
ui_set(limit, 60)
ui_set(body, "Static")
elseif ui.get(LegitAABreaker) == "Maximum" then
ui_set(limit, 60)
ui_set(body, "Static")
elseif ui.get(LegitAABreaker) == "Jitter" then
ui_set(body, "Jitter")

end
end
end
function slot163()
if ui.get(legitAA) then
if ui.get(LegitAABreaker) == "Maximum" then
-- ui_set(body, "Opposite")
elseif ui.get(LegitAABreaker) == "Smart" then
--  ui_set(lby, "Eye yaw")
end
else
--  ui_set(lby, "Off")
end
end
client.set_event_callback("run_command", function()
slot160()
end)
client.set_event_callback("paint", function(c)
slot163()
dodynamic()
end)
client.set_event_callback("game_newmap", function()
end)
function GetClosestPoint(A, B, P)
a_to_p = { P[1] - A[1], P[2] - A[2] }
a_to_b = { B[1] - A[1], B[2] - A[2] }
atb2 = a_to_b[1] ^ 2 + a_to_b[2] ^ 2
atp_dot_atb = a_to_p[1] * a_to_b[1] + a_to_p[2] * a_to_b[2]
t = atp_dot_atb / atb2
return
{ A[1] + a_to_b[1] * t, A[2] + a_to_b[2] * t }
end
should_swap = false
client.set_event_callback("bullet_impact", function(c)
if ui.get(legitaa_freestand_type) == "Flip + Manual" and ui.get(legitAA, true) and ui.get(legitAAbase) == "Dynamic" then
else
return
end
if entity_is_alive(entity.get_local_player()) then
local ent = client_userid_to_entindex(c.userid)
if not entity_is_dormant(ent) and entity_is_enemy(ent) then
local ent_shoot = { entity_get_prop(ent, "m_vecOrigin") }
ent_shoot[3] = ent_shoot[3] + entity_get_prop(ent, "m_vecViewOffset[2]")
local player_head = { entity_hitbox_position(entity_get_local_player(), 0) }
local closest = GetClosestPoint(ent_shoot, { c.x, c.y, c.z }, player_head)
local delta = { player_head[1] - closest[1], player_head[2] - closest[2] }
local delta_2d = math.sqrt(delta[1] ^ 2 + delta[2] ^ 2)
if math.abs(delta_2d) < 32 then
should_swap = true
end
end
end
end)
client_set_event_callback("run_command", function(c)
if ui.get(legitaa_freestand_type) == "Flip + Manual" and ui.get(legitAA, true) and ui.get(legitAAbase) == "Dynamic" then
else
return
end
if should_swap then
ui_set(body_num, -ui.get(body_num))
should_swap = false
end
end)
canchange = false
function setbyaw()
if ui.get(legitaa_freestand_type) == "Flip + Manual" and ui.get(legitAA, true) and ui.get(legitAAbase) == "Dynamic" then
else
return
end
if ui.get(body_num) == 55 and canchange == true then
ui_set(body_num, -55)
canchange = false
end
if ui.get(body_num) == -55 and canchange == true then
ui_set(body_num, 55)
canchange = false
end
end
function change_paint()
if ui.get(legitaa_freestand_type) == "Flip + Manual" and ui.get(legitAA, true) and ui.get(legitAAbase) == "Dynamic" then
else
return
end
if ui.get(flip_key) then
if canchange == true then
setbyaw()
canchange = false
end
else
canchange = true
end
end
client_set_event_callback("paint", change_paint)
function set_paint()
if ui.get(legitaa_freestand_type) == "Flip + Manual" and ui.get(legitAA, true) and ui.get(legitAAbase) == "Dynamic" then
else
return
end
if not ui.get(body_num) == -55 or not ui.get(body_num) == 55 then
ui_set(body_num, 55)
end
end
--client.set_event_callback("paint", set_paint)
--aa indicator
function on_paint(c)
local scrsize_x, scrsize_y = client_screen_size()
local center_x, center_y = scrsize_x / 2, scrsize_y / 2
local indicator = ui.get(ui_indicator_combobox4)
local indicator_r, indicator_g, indicator_b, indicator_a = ui.get(ui_indicator_color_picker4)
local local_player = entity_get_local_player()
if not local_player or not entity_is_alive(local_player) then
return
end
if ui.get(body_num) == 55 and indicator == "Metro" and ui.get(legitAA) == true or ui.get(body_num) == 180 and indicator == "Metro" and ui.get(legitAA) == true then
client_draw_text(c, center_x + 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a, "c+", 0, "►")
elseif ui.get(body_num) == -55 and indicator == "Metro" and ui.get(legitAA) == true or ui.get(body_num) == -180 and indicator == "Metro" and ui.get(legitAA) == true then
client_draw_text(c, center_x - 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a, "c+", 0, "◄")
end
if ui.get(body_num) == 55 and indicator == "Big Arrows" and ui.get(legitAA) == true then
client_draw_text(c, center_x + 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a,  "c+", 255, "⯈")
elseif ui.get(body_num) == -55 and indicator == "Big Arrows" and ui.get(legitAA) == true then
client_draw_text(c, center_x - 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a,  "c+",  255, "⯇")
end
if ui.get(body_num) == 55 and indicator == "Dashes" and ui.get(legitAA) == true then
client_draw_text(c, center_x + 45, center_y-6, indicator_r, indicator_g, indicator_b, indicator_a, " ", 255, "―")
elseif ui.get(body_num) == -55 and indicator == "Dashes" and ui.get(legitAA) == true then
client_draw_text(c, center_x - 45, center_y-6, indicator_r, indicator_g, indicator_b, indicator_a, " ", 255, "―")
end
end
err = client.set_event_callback('paint', on_paint)
duck_peek_ref = ui_reference("RAGE", "Other", "Duck peek assist")
body_yaw_ref = ui_reference("AA", "Anti-aimbot angles", "Body yaw")
function on_run_command()
ui_set(body_yaw_ref, ui.get(duck_peek_ref) and "Off" or "Static")
end
client.set_event_callback("run_command", on_run_command)
client.set_event_callback("paint", function()
if not ui.get(rageautofiremagnet) then
return
else
if ui.get(rageautofiremagnet)    then
renderer_indicator(235, 70, 137, 255, "MT")
else
end
end
end)
client.set_event_callback("paint", function()
if not ui.get(force_body_aim) then
return
else
if ui.get(force_body_aim)    then
renderer_indicator(255, 255, 255, 255, "BAIM")
else
end
end
end)
----------------------------------------------------------------------------------
usr = entity.get_player_name(entity.get_local_player())
sX, sY = client_screen_size()
sXc = sX/2
sYc = sY/2
sendNotification("Doggosense.lua loaded!", 1)
client_delay_call(1, sendNotification, "Welcome " .. usr .. "!", 0)

function drawNotification()
local hours, minutes, seconds = client_system_time()
string.format("%02d", seconds)
for i=1, #notifications do
if notifications[i] ~= nil then
if notifyTime ~= seconds and notifications[i][2] == 0 then
notifications[i][4] = notifications[i][4] - 1
end
local textW, textH = renderer.measure_text("rd",  notifications[i][1])
local Y = sYc + (textH*2.5*i) - textH*2.5
if notifications[i][4] > 0 then
if notifications[i][5] < Y -15 then
notifications[i][5] = notifications[i][5] + 3
elseif notifications[i][5] < Y - 1 then
notifications[i][5] = notifications[i][5] + 1
elseif notifications[i][5] > Y then
notifications[i][5] = notifications[i][5] - 3
end
if notifications[i][2]	== -1 then
notifications[i][2] = textW*2+17
end
if notifications[i][2] > 15 then
notifications[i][2] = notifications[i][2] - 5
elseif notifications[i][2] > 0 then
notifications[i][2] = notifications[i][2] - 1
end
if notifications[i][3] < 240 then
notifications[i][3] = notifications[i][3] + 5
elseif notifications[i][3] < 255 then
notifications[i][3] = notifications[i][3] + 1
end
elseif notifications[i][4] <= 0 and notifications[i][3] > 0 then
if notifications[i][2] < textW*2+17 then
notifications[i][2] = notifications[i][2] + 8
end
if notifications[i][3] > 0 then
notifications[i][3] = notifications[i][3] - 10
end
elseif notifications[i][3] <= 0 then
table.remove(notifications, i)
end
if notifications[i] ~= nil then
renderer.rectangle(sX-textW-22+notifications[i][2], notifications[i][5]-7, sX-(sX-textW)+24, textH + 14, 15, 15, 15, notifications[i][3])
renderer.rectangle(sX-textW-21+notifications[i][2], notifications[i][5]-6, sX-(sX-textW)+22, textH + 12, 55, 55, 55, notifications[i][3])
renderer.rectangle(sX-textW-20+notifications[i][2], notifications[i][5]-5, sX-(sX-textW)+20, textH + 10, 0, 0, 0, notifications[i][3])
renderer.triangle(sX-textW-39+notifications[i][2], notifications[i][5]+textH+7, sX-textW-22+notifications[i][2], notifications[i][5]-8, sX-textW-22+notifications[i][2], notifications[i][5]+textH+7, 15, 15, 15, notifications[i][3])
renderer.triangle(sX-textW-37+notifications[i][2], notifications[i][5]+textH+6, sX-textW-21+notifications[i][2], notifications[i][5]-7, sX-textW-21+notifications[i][2], notifications[i][5]+textH+6, 55, 55, 55, notifications[i][3])
renderer.triangle(sX-textW-35+notifications[i][2], notifications[i][5]+textH+5, sX-textW-20+notifications[i][2], notifications[i][5]-6, sX-textW-20+notifications[i][2], notifications[i][5]+textH+5, 0, 0, 0, notifications[i][3])
renderer.text(sX-13+notifications[i][2], notifications[i][5], 255, 255, 255, notifications[i][3], "rd", 0, notifications[i][1])
end
end
end
if notifyTime ~= seconds then
notifyTime = seconds
end
end
client.set_event_callback("paint_ui",
function()
drawNotification()
end
)
--logo
local function hsv_to_rgb(h, s, v, a)
local r, g, b
local i = math.floor(h * 6);
local f = h * 6 - i;
local p = v * (1 - s);
local q = v * (1 - f * s);
local t = v * (1 - (1 - f) * s);
i = i % 6
if i == 0 then r, g, b = v, t, p
elseif i == 1 then r, g, b = q, v, p
elseif i == 2 then r, g, b = p, v, t
elseif i == 3 then r, g, b = p, q, v
elseif i == 4 then r, g, b = t, p, v
elseif i == 5 then r, g, b = v, p, q
end

return r * 255, g * 255, b * 255, a * 255
end
local function func_rgb_rainbowize(frequency, rgb_split_ratio)
local r, g, b, a = hsv_to_rgb(globals.realtime() * frequency, 1, 1, 1)
r = r * rgb_split_ratio
g = g * rgb_split_ratio
b = b * rgb_split_ratio
return r, g, b
end
local function handle_paint(ctx)
local r, g, b = func_rgb_rainbowize(0.1, 1)
client_draw_indicator(ctx, r, g, b, 255, "Doggosense")
end
client.set_event_callback("paint", handle_paint)
-----------------------
--Watermark
bit = require "bit"
-- cache common functions
renderer = renderer
gradient, rectangle, text, measure_text = renderer.gradient, renderer.rectangle, renderer.text, renderer.measure_text
get_screen_size, get_latency, get_system_time = client.screen_size, client.latency, client.system_time
get_absoluteframetime, get_tickinterval, get_realtime = globals.absoluteframetime, globals.tickinterval, globals.realtime
get_local_player, get_prop, get_name, get_all = entity.get_local_player, entity.get_prop, entity.get_player_name, entity.get_all
min, max, abs, sqrt, floor = math.min, math.max, math.abs, math.sqrt, math.floor
band, bnot, bor = bit.band, bit.bnot, bit.bor
frametimes = {}
fps_prev = 0
value_prev = {}
last_update_time = 0
wdei, hdei = client_screen_size()
scr = { w = wdei, h = hdei }
menu_color = ui_reference("misc", "settings", "menu color")
rm, gm, bm, am = ui.get(menu_color)
local kokot = {
enabled = ui.new_checkbox("visuals", "other esp", "Watermark"),
--   color = ui.new_color_picker("visuals", "other esp", "watermark_color", rm, gm, bm, am),
options = ui_new_multiselect("visuals", "other esp", "\n", "Watermark", "Version", "Username", "Time", "FPS", "Latency", "Server tickrate")
}
local widths = {
["Watermark"] = 60,
["Version"] = 25,
["Username"] = 10,
["Time"] = 40,
["FPS"] = 40,
["Latency"] = 35,
["Server tickrate"] = 45
}
-- round to whole number
function tointeger(n)
return floor(n + 0.5)
end
function accumulate_fps() -- stolen from estk
local rt, ft = get_realtime(), get_absoluteframetime()
if ft > 0 then
table.insert(frametimes, 1, ft)
end
local count = #frametimes
if count == 0 then
return 0
end
local accum = 0
local i = 0
while accum < 0.5 do
i = i + 1
accum = accum + frametimes[i]
if i >= count then
break
end
end
accum = accum / i
while i < count do
i = i + 1
table.remove(frametimes)
end
local fps = 1 / accum
local time_since_update = rt - last_update_time
if abs(fps - fps_prev) > 4 or time_since_update > 1 then
fps_prev = fps
last_update_time = rt
else
fps = fps_prev
end
return floor(fps + 0.5)
end
function contains(tbl, val)
for i = 1, #tbl do
if tbl[i] == val then return true end
end
return false
end
function container(x, y, w, h)
--    local r, g, b, a = ui.get(int.color)
rectangle(x, y, w, h, 30, 30, 30, 200)
rectangle(x+1, y+1, w-2, 1, 235, 70, 137, 255)
end
draw = { container = container }
function round(num, numdec)
return floor(num * (10^(numdec or 0)) + 0.5) / 10^(numdec or 0)
end
function on_paint()
local width, height = 3, 18
local p_res = entity_get_all("CCSPlayerResource")[1]
local options = ui.get(kokot.options)
local latency = min(999, client_latency() * 1000)
local fps = accumulate_fps()
--   local r, g, b, a = ui.get(int.color)
local me = get_local_player()
local name = "FH PASTE"
local vx, vy = entity_get_prop(me, "m_vecVelocity")
local hours, minutes, seconds, milliseconds = client_system_time()
local timess = "AM"
if string.len(name) > 20 then name = string.sub(get_name(me), 0, 21) end
if hours > 12 then
hours = hours-12
timess = "PM"
end
if minutes < 10 then minutes = "0" .. minutes end

for i=1, #options do
local option = options[i]
if option == "FPS" then
widths[option] = measure_text("", fps) + measure_text("-", "  FPS") + 9
end
if option == "Latency" then
widths[option] = measure_text("", tointeger(latency)) + measure_text("-", "  PING") + 9
end
if option == "Username" then
widths[option] = measure_text("", name) + 9
end
if option == "Time" then
widths[option] = measure_text("", hours .. ":" .. minutes .. timess) + 9
end
if option == "Server tickrate" then
widths[option] = measure_text("", 1 / get_tickinterval()) + measure_text("-", "  TICKS") + 9
end
if widths[option] ~= nil then
width = width + widths[option]
end
end
local txt = { x = scr.w-width, y = 9 }
if ui.get(kokot.enabled) then
draw.container(scr.w-width-5, 5, width, height)
for i=1, #options do
local option = options[i]
if option == "FPS" then
local fpsc = { a = 255 }
text(txt.x, txt.y, 255, 255, 255, 255, "", 0, fps)
text(txt.x+measure_text("", fps), txt.y+3, 235, 70, 137, fpsc.a, "-", 0, "FPS")
elseif option == "Username" then
text(txt.x, txt.y, 255, 255, 255, 255, "", 0, name)
elseif option == "Watermark" then
text(txt.x, txt.y-1, 255, 255, 255, 255, "", 0, "Shitty")
text(txt.x+measure_text("", "Shitty"), txt.y-1, 235, 70, 137, 255, "", 0, "sense")
elseif option == "Version" then
text(txt.x, txt.y-1, 255, 0, 0, 255, "", 0, "beta")
elseif option == "Latency" then
local ping = {a = 255 }
text(txt.x, txt.y, 255, 255, 255, 255, "", 0, tointeger(latency))
text(txt.x+measure_text("", tointeger(latency)), txt.y+3, 235, 70, 137, ping.a, "-", 0, " PING")
elseif option == "Time" then
text(txt.x, txt.y, 255, 255, 255, 255, "", 0, hours)
text(txt.x+measure_text("", hours), txt.y, 255, 255, 255, 255, "", 0, ":")
text(txt.x+measure_text("", hours .. ":"), txt.y, 255, 255, 255, 255, "", 0, minutes)
text(txt.x+measure_text("", hours .. ":" .. minutes), txt.y+3, 235, 70, 137, 255, "-", 0, timess)
elseif option == "Server tickrate" then
text(txt.x, txt.y, 255, 255, 255, 255, "", 0, 1 / get_tickinterval())
text(txt.x+measure_text("", 1 / get_tickinterval()), txt.y+3, 235, 70, 137, 255, "-", 0, " TICKS")
end
if widths[option] ~= nil then
txt.x = txt.x + widths[option]
end
if #options > i then
text(txt.x-10, txt.y-1, 255, 255, 255, 255, "", 0, " | ")
end
end
end
if #options == 0 then return end
end
client.set_event_callback("paint", on_paint)
-----------------------
